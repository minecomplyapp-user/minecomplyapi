import type { CMVRGeneralInfo } from './cmvr-pdf-generator.service';
import {
  formatDate,
  formatMaybeDateOrRange,
  getOrdinalSuffix,
  formatQuarterWithSuperscript,
} from './cmvr-pdf.helpers';

/**
 * Rendering helper functions for CMVR PDF generation
 * This file contains functions that directly manipulate the PDFDocument for rendering tables and text
 */

/**
 * Add footer to the PDF document
 */
export function addFooter(doc: PDFKit.PDFDocument): void {
  const text = 'Generated by MineComply';
  const y = doc.page.height - (doc.page.margins.bottom || 50) + 20;
  doc
    .font('Helvetica-Oblique')
    .fontSize(8)
    .fillColor('#666666')
    .text(text, doc.page.margins.left || 50, y, {
      width:
        doc.page.width -
        (doc.page.margins.left || 50) -
        (doc.page.margins.right || 50),
      align: 'center',
    })
    .fillColor('#000000');
}

/**
 * Draw a two-column key/value table WITHOUT a header row
 */
export function drawKeyValueTableNoHeader(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const colWidths = [tableWidth * 0.5, tableWidth * 0.5];
  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the table (since there's no header)
  doc
    .moveTo(left, y)
    .lineTo(left + tableWidth, y)
    .stroke();

  for (const [key, value] of rows) {
    const textHeightLeft = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const textHeightRight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const rowHeight =
      Math.max(rowMinHeight, textHeightLeft, textHeightRight) + 3; // padding

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: left/right edges, internal divider, bottom line
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Column divider
    doc
      .moveTo(left + colWidths[0], y)
      .lineTo(left + colWidths[0], y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Cell text (centered vertically)
    const keyTextHeight = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const valueTextHeight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const keyTextY = y + (rowHeight - keyTextHeight) / 2;
    const valueTextY = y + (rowHeight - valueTextHeight) / 2;

    doc.font('Helvetica').text(key, left + 5, keyTextY, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    doc
      .font('Helvetica-Bold')
      .text(value, left + colWidths[0] + 5, valueTextY, {
        width: colWidths[1] - 10,
        align: 'center',
      });

    y += rowHeight;
  }
  doc.moveDown(1);
}

/**
 * Draw a key/value table with label and colon columns (no header row)
 */
export function drawKeyValueTableWithColon(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
  suppressBottomSpacing?: boolean,
  customLabelColWidth?: number,
  customValueColWidth?: number,
  connectPrevious?: boolean,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Use custom widths if provided, otherwise use same dimensions as ECC/ISAG/MPP tables
  const labelColWidth = customLabelColWidth ?? 70;
  const colonColWidth = 15;
  const valueColWidth =
    customValueColWidth ?? tableWidth - labelColWidth - colonColWidth;

  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the entire table (skip if connecting to previous section)
  if (!connectPrevious) {
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();
  }

  for (const [key, value] of rows) {
    // Handle newlines in both key and value
    // Replace literal \n strings with actual newline characters
    // Also ensure existing newlines are preserved
    const processedKey = key.replace(/\\n/g, '\n');
    const processedValue = value.replace(/\\n/g, '\n');

    // Set font before measuring to ensure accurate height calculation
    doc.font('Helvetica-Bold').fontSize(11);
    const labelHeight = doc.heightOfString(processedKey, {
      width: labelColWidth - 10,
      align: 'left',
    });

    doc.font('Helvetica').fontSize(11);
    const valueHeight = doc.heightOfString(processedValue, {
      width: valueColWidth - 10,
      align: 'center',
    });

    const rowHeight = Math.max(rowMinHeight, labelHeight, valueHeight) + 8;

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: outer edges and dividers
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Divider between label and colon
    doc
      .moveTo(left + labelColWidth, y)
      .lineTo(left + labelColWidth, y + rowHeight)
      .stroke();
    // Divider between colon and value
    doc
      .moveTo(left + labelColWidth + colonColWidth, y)
      .lineTo(left + labelColWidth + colonColWidth, y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Draw label text (left-aligned, vertically centered)
    const labelTextY = y + (rowHeight - labelHeight) / 2;
    doc.font('Helvetica-Bold').text(processedKey, left + 5, labelTextY, {
      width: labelColWidth - 10,
      align: 'left',
    });

    // Draw colon (centered horizontally and vertically)
    const colonY = y + rowHeight / 2 - 5;
    doc.font('Helvetica-Bold').text(':', left + labelColWidth, colonY, {
      width: colonColWidth,
      align: 'center',
    });

    // Draw value text (center-aligned, vertically centered)
    const valueTextY = y + (rowHeight - valueHeight) / 2;
    doc
      .font('Helvetica')
      .text(
        processedValue,
        left + labelColWidth + colonColWidth + 5,
        valueTextY,
        {
          width: valueColWidth - 10,
          align: 'center',
        },
      );

    y += rowHeight;
  }

  // Update document cursor to the end of the table
  doc.y = y;

  if (!suppressBottomSpacing) {
    doc.moveDown(1);
  }
}

/**
 * Draw a table with optional merged label column
 */
export function drawTable(
  doc: PDFKit.PDFDocument,
  opts: {
    headers: string[];
    rows: string[][];
    labelColumn?: string;
    columnWidths?: number[]; // Optional: array of percentages (0-1) for each column
    connectPrevious?: boolean; // If true, visually connect this table to the previous one on the same page
    suppressBottomSpacing?: boolean; // If true, don't add extra spacing after the table
    suppressBottomBorder?: boolean; // If true, only draw bottom border under label area (another section follows)
  },
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // If labelColumn is provided, reserve space for label column + colon column on the left
  const labelColWidth = opts.labelColumn ? 70 : 0;
  const colonColWidth = opts.labelColumn ? 15 : 0;
  const dataTableWidth = tableWidth - labelColWidth - colonColWidth;

  // Calculate column widths - either custom or equal distribution
  let colWidths: number[];
  if (opts.columnWidths && opts.columnWidths.length === opts.headers.length) {
    // Use custom widths (percentages that should sum to 1.0)
    colWidths = opts.columnWidths.map((pct) => dataTableWidth * pct);
  } else {
    // Equal distribution
    const colWidth = dataTableWidth / opts.headers.length;
    colWidths = Array(opts.headers.length).fill(colWidth) as number[];
  }

  // Compute dynamic header height based on header text wrapping
  const rowMinHeight = 14;
  // Ensure header font is set before measuring
  doc.font('Helvetica-Bold').fontSize(11);
  const headerTextHeights = opts.headers.map((h, idx) =>
    doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    }),
  );
  const headerPadding = 10; // vertical padding within header
  const headerHeight = Math.max(25, ...headerTextHeights) + headerPadding;
  let y = doc.y;

  // Pre-calculate all row heights (use center align to match final rendering)
  const rowHeights: number[] = [];
  for (const row of opts.rows) {
    const heights = row.map((txt, idx) =>
      doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      }),
    );
    rowHeights.push(Math.max(rowMinHeight, ...heights) + 3);
  }

  // Determine if we should actually connect on this page (only if not at top of a new page)
  const topMargin = doc.page.margins.top || 50;
  const connectPrevHere = !!(opts.connectPrevious && doc.y > topMargin + 2);
  // Track whether to draw the section's top line (skip if connected to previous on same page)
  let shouldDrawSectionTop = !connectPrevHere;

  // Helper function to draw label and colon columns for a section
  const drawLabelSection = (
    startY: number,
    sectionHeight: number,
    drawTop: boolean,
    drawBottom: boolean,
  ) => {
    if (!opts.labelColumn) return;

    // Draw label column vertical edge (left outer edge)
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, startY)
      .lineTo(left, startY + sectionHeight)
      .stroke();

    // Draw top horizontal line spanning label + colon + data for this section (optional)
    if (drawTop) {
      doc
        .moveTo(left, startY)
        .lineTo(left + tableWidth, startY)
        .stroke();
    }

    // Bottom border handling (similar to fund section logic)
    if (drawBottom) {
      // Draw full width bottom border
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(left + tableWidth, startY + sectionHeight)
        .stroke();
    } else {
      // Only draw under label+colon area when another section follows
      const colonRight = left + labelColWidth + colonColWidth;
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(colonRight, startY + sectionHeight)
        .stroke();
    }

    // Vertically center the label text
    const labelY = startY + sectionHeight / 2 - 5;
    doc
      .font('Helvetica-Bold')
      .fontSize(12)
      .text(opts.labelColumn.toUpperCase(), left + 5, labelY, {
        width: labelColWidth - 10,
        align: 'center',
      });

    // Draw colon column: only the divider between label and colon (no right edge to avoid double with dataLeft)
    const colonLeft = left + labelColWidth;
    doc
      .moveTo(colonLeft, startY)
      .lineTo(colonLeft, startY + sectionHeight)
      .stroke();

    // Vertically center the colon
    const colonY = startY + sectionHeight / 2 - 5;
    doc.font('Helvetica-Bold').fontSize(12).text(':', colonLeft, colonY, {
      width: colonColWidth,
      align: 'center',
    });
  };

  // Offset data columns to the right if label column exists
  const dataLeft = left + labelColWidth + colonColWidth;

  // Helper to get X position for a column (cumulative width up to that column)
  const getColX = (colIndex: number): number => {
    return (
      dataLeft + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0)
    );
  };

  // Track section start for merged label column
  let sectionStartY = y;
  let sectionRowsHeight = headerHeight; // Start with header height

  // Header for data columns - draw borders without double lines
  doc.font('Helvetica-Bold').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Header outer edges
  doc
    .moveTo(dataLeft, y)
    .lineTo(dataLeft, y + headerHeight)
    .stroke(); // Left
  doc
    .moveTo(dataLeft + dataTableWidth, y)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Right
  // Top border is drawn by drawLabelSection to avoid double lines; skip drawing top here
  doc
    .moveTo(dataLeft, y + headerHeight)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Bottom

  // Header column dividers
  for (let i = 1; i < opts.headers.length; i++) {
    const colX = getColX(i);
    doc
      .moveTo(colX, y)
      .lineTo(colX, y + headerHeight)
      .stroke();
  }

  opts.headers.forEach((h, idx) => {
    const colX = getColX(idx);
    const textHeight = doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
    const textY = y + (headerHeight - textHeight) / 2; // vertical center
    doc.text(h, colX + 5, textY, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
  });
  y += headerHeight;
  doc.font('Helvetica').fontSize(11);

  opts.rows.forEach((row, rowIndex) => {
    const rowHeight = rowHeights[rowIndex];

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      // Draw label section for rows on current page before page break (not final, so respect suppressBottomBorder)
      drawLabelSection(
        sectionStartY,
        sectionRowsHeight,
        shouldDrawSectionTop,
        !opts.suppressBottomBorder, // drawBottom: false if another section follows
      );
      // After first segment, always draw top for subsequent segments
      shouldDrawSectionTop = true;

      doc.addPage();
      y = doc.page.margins.top || 50;

      // Reset section tracking for new page
      sectionStartY = y;
      sectionRowsHeight = headerHeight;

      // redraw header
      doc
        .font('Helvetica-Bold')
        .fontSize(11)
        .strokeColor('#000000')
        .lineWidth(0.5);

      // Header outer edges
      doc
        .moveTo(dataLeft, y)
        .lineTo(dataLeft, y + headerHeight)
        .stroke(); // Left
      doc
        .moveTo(dataLeft + dataTableWidth, y)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Right
      // Top border is handled by drawLabelSection later to avoid double lines; skip drawing top here
      doc
        .moveTo(dataLeft, y + headerHeight)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Bottom

      // Header column dividers
      for (let i = 1; i < opts.headers.length; i++) {
        const colX = getColX(i);
        doc
          .moveTo(colX, y)
          .lineTo(colX, y + headerHeight)
          .stroke();
      }
      opts.headers.forEach((h, idx) => {
        const colX = getColX(idx);
        const textHeight = doc.heightOfString(h, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
        const textY = y + (headerHeight - textHeight) / 2; // vertical center
        doc.text(h, colX + 5, textY, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
      });
      y += headerHeight;
      doc.font('Helvetica').fontSize(11);
    }

    // Row borders (no double lines): draw left/right edges and the bottom line only
    // Left outer edge
    doc
      .moveTo(dataLeft, y)
      .lineTo(dataLeft, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(dataLeft + dataTableWidth, y)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();
    // Internal column dividers
    for (let i = 1; i < opts.headers.length; i++) {
      const colX = getColX(i);
      doc
        .moveTo(colX, y)
        .lineTo(colX, y + rowHeight)
        .stroke();
    }
    // Bottom horizontal line only under data area (preserve merged label/colon appearance)
    doc
      .moveTo(dataLeft, y + rowHeight)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();

    // Row cells (centered horizontally and vertically)
    row.forEach((txt, idx) => {
      const colX = getColX(idx);
      const textHeight = doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
      const textY = y + (rowHeight - textHeight) / 2; // vertical center
      doc.text(txt, colX + 5, textY, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
    });

    y += rowHeight;
    sectionRowsHeight += rowHeight; // Accumulate height for label section
  });

  // Draw final label section for last page (this is the final segment)
  drawLabelSection(
    sectionStartY,
    sectionRowsHeight,
    shouldDrawSectionTop,
    !opts.suppressBottomBorder, // drawBottom: false if another section follows
  );

  // Update document cursor position to end of table
  doc.y = y;
  if (!opts.suppressBottomSpacing) {
    doc.moveDown(0.5);
  }
}

/**
 * Draw the summary text section with formatted title and company info
 */
export function drawSummaryText(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const width = right - left;
  const boxPct = 0.8;
  const boxPctLocation = 0.9;
  const y = width * boxPctLocation;
  const w = width * boxPct;
  const x = left + (width - w) / 2;
  const z = left + (width - y) / 2;

  doc.moveDown(0.8);

  // Title: "3rd QUARTER CY 2025 MMT COMPLIANCE MONITORING AND VALIDATION REPORT"
  doc.font('Helvetica-Bold').fontSize(11);

  const titleParts: string[] = [];
  if (gi.quarter) {
    // Format quarter with superscript ordinal (e.g., "3RD" becomes "3" with superscript "RD")
    const quarterFormatted = formatQuarterWithSuperscript(gi.quarter);
    titleParts.push(quarterFormatted);
  }
  if (gi.year) {
    titleParts.push(`CY ${gi.year}`);
  }
  titleParts.push('MMT COMPLIANCE MONITORING');

  // First line of title
  const titleLine1 = titleParts.join(' ');

  // If quarter has superscript, we need to manually draw it
  if (gi.quarter) {
    const yPos = doc.y;
    const quarterNum = gi.quarter.replace(/\D/g, ''); // Extract number
    const ordinal = getOrdinalSuffix(parseInt(quarterNum, 10)); // Get suffix

    // Build the text parts
    const afterQuarter = ' QUARTER';
    const restOfTitle = titleParts.slice(1).join(' ');

    // Measure to center the whole line (approximate with regular font for ordinal)
    const fullTextApprox = `${quarterNum}${ordinal}${afterQuarter} ${restOfTitle}`;
    const textWidth = doc.widthOfString(fullTextApprox);
    let xPos = left + (width - textWidth) / 2;

    // Draw quarter number
    doc.fontSize(11);
    doc.text(quarterNum, xPos, yPos, { continued: false });
    xPos += doc.widthOfString(quarterNum);

    // Draw ordinal as superscript (smaller font, raised) - no space before it
    doc.fontSize(7);
    const ordinalWidth = doc.widthOfString(ordinal);
    doc.text(ordinal, xPos, yPos - 1.5, { continued: false });
    xPos += ordinalWidth;

    // Draw rest of line
    doc.fontSize(11);
    doc.text(`${afterQuarter} ${restOfTitle}`, xPos, yPos, {
      continued: false,
    });
    doc.moveDown(0.5);
  } else {
    doc.text(titleLine1, left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  // Second line
  doc.text('AND VALIDATION REPORT', left, doc.y, {
    width: width,
    align: 'center',
  });
  doc.moveDown(2);

  // Company name centered
  if (gi.projectCurrentName) {
    doc.text(gi.projectCurrentName.toUpperCase(), left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  doc.font('Helvetica');

  doc.text(
    `(This CMVR covers the ISAG Permit of ONRI and Fourteen (14) ISAG Permits under Supply Agreement with ONRI)`,
    x,
    doc.y,
    {
      width: w,
      align: 'center',
    },
  );

  doc.moveDown(1).font('Helvetica-Bold');

  // Display location field if it's a string, otherwise use mailing address
  if (typeof gi.location === 'string') {
    doc.text(gi.location.toUpperCase(), z, doc.y, {
      width: y,
      align: 'center',
    });
  }

  doc.moveDown(1);
}

/**
 * Add general info key-value pairs (compliance dates and summary)
 */
export function addGeneralInfoKeyValues(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  // Render summary as formatted text (not a table) and compliance dates as a no-header table

  const complianceRows: Array<[string, string]> = [];

  if (gi.dateOfComplianceMonitoringAndValidation) {
    complianceRows.push([
      'Date of Compliance Monitoring and Validation',
      formatDate(gi.dateOfComplianceMonitoringAndValidation),
    ]);
  }
  if (gi.monitoringPeriodCovered) {
    complianceRows.push([
      'Monitoring Period Covered',
      formatMaybeDateOrRange(gi.monitoringPeriodCovered),
    ]);
  }
  if (gi.dateOfCmrSubmission) {
    complianceRows.push([
      'Date of CMR Submission',
      formatDate(gi.dateOfCmrSubmission),
    ]);
  }

  // Render summary section as formatted text (no "SUMMARY" title)
  drawSummaryText(doc, gi);

  if (complianceRows.length > 0) {
    // Render the three compliance-related rows as a separate table without a header
    drawKeyValueTableNoHeader(doc, complianceRows);
  }
}

/**
 * Draw "Executive Summary of Compliance" section with a multi-row header.
 * Header structure:
 *   Row 1: "Requirements" (merged 2 rows) | "Complied?" (spans Y+N) | "Remarks/ ECC or EPEP Condition #" (merged 2 rows)
 *   Row 2:                                 | "Y" | "N"                |
 *
 * For each requirement, mark Y or N based on boolean values.
 */
export function drawExecutiveSummaryOfCompliance(
  doc: PDFKit.PDFDocument,
  exec: NonNullable<CMVRGeneralInfo['executiveSummaryOfCompliance']>,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  const reqWidth = tableWidth * 0.57;
  const yWidth = tableWidth * 0.1;
  const nWidth = tableWidth * 0.1;
  const remarksWidth = tableWidth * 0.23;
  const compliedWidth = yWidth + nWidth; // "Complied?" spans Y + N

  const rowMinHeight = 14;
  const headerRow1Height = 20; // First header row
  const headerRow2Height = 18; // Second header row (Y/N)
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get column X positions
  const reqX = left;
  const yX = left + reqWidth;
  const nX = yX + yWidth;
  const remarksX = nX + nWidth;

  // Helper to draw the two-row header
  const drawHeader = (y: number) => {
    doc
      .strokeColor('#000000')
      .lineWidth(0.5)
      .font('Helvetica-Bold')
      .fontSize(11);

    // --- Header Row 1 ---
    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + headerRow1Height + headerRow2Height)
      .stroke();
    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + headerRow1Height + headerRow2Height)
      .stroke();

    // Vertical dividers for row 1
    doc
      .moveTo(yX, y)
      .lineTo(yX, y + headerRow1Height + headerRow2Height)
      .stroke(); // After Requirements
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + headerRow1Height + headerRow2Height)
      .stroke(); // After Complied?

    // Horizontal line after row 1
    doc
      .moveTo(yX, y + headerRow1Height)
      .lineTo(remarksX, y + headerRow1Height)
      .stroke();

    // Bottom border of header row 2
    doc
      .moveTo(left, y + headerRow1Height + headerRow2Height)
      .lineTo(left + tableWidth, y + headerRow1Height + headerRow2Height)
      .stroke();

    // --- Header Row 2 (Y/N sub-columns) ---
    doc
      .moveTo(nX, y + headerRow1Height)
      .lineTo(nX, y + headerRow1Height + headerRow2Height)
      .stroke();

    // Draw header texts
    // "Requirements" - vertically centered across both rows
    const reqText = 'Requirements';
    const reqTextHeight = doc.heightOfString(reqText, { width: reqWidth - 10 });
    const reqTextY =
      y + (headerRow1Height + headerRow2Height - reqTextHeight) / 2;
    doc.text(reqText, reqX + 5, reqTextY, {
      width: reqWidth - 10,
      align: 'center',
    });

    // "Complied?" - centered in row 1 only
    const compliedText = 'Complied?';
    const compliedTextHeight = doc.heightOfString(compliedText, {
      width: compliedWidth - 10,
    });
    const compliedTextY = y + (headerRow1Height - compliedTextHeight) / 2;
    doc.text(compliedText, yX + 5, compliedTextY, {
      width: compliedWidth - 10,
      align: 'center',
    });

    // "Remarks/ ECC or EPEP Condition #" - vertically centered across both rows
    const remarksText = 'Remarks/ ECC or EPEP Condition #';
    const remarksTextHeight = doc.heightOfString(remarksText, {
      width: remarksWidth - 10,
    });
    const remarksTextY =
      y + (headerRow1Height + headerRow2Height - remarksTextHeight) / 2;
    doc.text(remarksText, remarksX + 5, remarksTextY, {
      width: remarksWidth - 10,
      align: 'center',
    });

    // "Y" and "N" in row 2
    const yText = 'Y';
    const nText = 'N';
    const yTextY =
      y +
      headerRow1Height +
      (headerRow2Height - doc.heightOfString(yText, { width: yWidth - 10 })) /
        2;
    const nTextY =
      y +
      headerRow1Height +
      (headerRow2Height - doc.heightOfString(nText, { width: nWidth - 10 })) /
        2;
    doc.text(yText, yX + 5, yTextY, { width: yWidth - 10, align: 'center' });
    doc.text(nText, nX + 5, nTextY, { width: nWidth - 10, align: 'center' });

    return y + headerRow1Height + headerRow2Height;
  };

  // Helper to draw a data row
  const drawRow = (
    y: number,
    requirement: string,
    complied: boolean | undefined,
    remarks: string,
    options?: {
      isSubRow?: boolean;
      subRowParentHeight?: number;
      isFirstSubRow?: boolean;
      isLastSubRow?: boolean;
      isOthersMerged?: boolean; // Flag for "Others" section to always merge Y+N
      showNA?: boolean; // Flag to show "N/A" text in merged cell
    },
  ) => {
    const {
      isSubRow,
      subRowParentHeight,
      isFirstSubRow,
      isLastSubRow,
      isOthersMerged,
      showNA,
    } = options || {};

    doc.font('Helvetica').fontSize(11);
    const reqTextHeight = doc.heightOfString(requirement, {
      width: reqWidth - 10,
    });
    const remarksTextHeight = doc.heightOfString(remarks, {
      width: remarksWidth - 10,
    });
    const rowHeight =
      Math.max(rowMinHeight, reqTextHeight, remarksTextHeight) + 4;

    // Check page break
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica').fontSize(11);
    }

    // Draw row borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Right
    doc
      .moveTo(yX, y)
      .lineTo(yX, y + rowHeight)
      .stroke(); // After Requirements

    // Only draw Y/N divider if not "Others" (which always has merged Y+N)
    if (!isOthersMerged) {
      doc
        .moveTo(nX, y)
        .lineTo(nX, y + rowHeight)
        .stroke(); // Between Y and N
    }

    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + rowHeight)
      .stroke(); // After N (or after merged Y+N)
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Bottom

    // Draw texts
    const reqTextY = y + (rowHeight - reqTextHeight) / 2;
    doc.text(requirement, reqX + 5, reqTextY, {
      width: reqWidth - 10,
      align: 'left',
    });

    // If "Others" section (merged Y+N), conditionally show "N/A" or leave empty
    if (isOthersMerged) {
      const compliedMergedWidth = yWidth + nWidth;
      if (showNA) {
        const naText = 'N/A';
        const naTextHeight = doc.heightOfString(naText, {
          width: compliedMergedWidth - 10,
        });
        const naTextY = y + (rowHeight - naTextHeight) / 2;
        doc.font('Helvetica').text(naText, yX + 5, naTextY, {
          width: compliedMergedWidth - 10,
          align: 'center',
        });
      }
      // If showNA is false, the merged cell remains empty (no text drawn)
    } else {
      // Draw a checkmark manually if complied is true
      if (complied === true) {
        const checkmarkSize = 4;
        const centerX = yX + yWidth / 2;
        const centerY = y + rowHeight / 2;

        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      // Draw a checkmark in N column if complied is false
      if (complied === false) {
        const checkmarkSize = 4;
        const centerX = nX + nWidth / 2;
        const centerY = y + rowHeight / 2;

        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }
    }

    const remarksTextY = y + (rowHeight - remarksTextHeight) / 2;
    doc.text(remarks, remarksX + 5, remarksTextY, {
      width: remarksWidth - 10,
      align: 'center',
    });

    return y + rowHeight;
  };

  // Build all rows from the data
  const allRows: Array<{
    requirement: string;
    complied: boolean | undefined;
    remarks: string;
    isOthersMerged?: boolean; // Flag for "Others" section to always merge Y+N
    showNA?: boolean; // Flag to show "N/A" text in merged cell
    subRows?: Array<{
      requirement: string;
      complied: boolean | undefined;
      remarks: string;
    }>;
  }> = [];

  // 1) Compliance with EPEP Commitments
  if (exec.complianceWithEpepCommitments) {
    const epep = exec.complianceWithEpepCommitments;
    allRows.push({
      requirement: 'Compliance with EPEP Commitments',
      complied: undefined, // This is a group label, no checkmark
      remarks: epep.remarks || '',
      subRows: [
        {
          requirement: 'Safety',
          complied: epep.safety,
          remarks: '', // Remarks are handled by the parent
        },
        {
          requirement: 'Social',
          complied: epep.social,
          remarks: '', // Remarks are handled by the parent
        },
        {
          requirement: 'Rehabilitation',
          complied: epep.rehabilitation,
          remarks: '', // Remarks are handled by the parent
        },
      ],
    });
  }

  // 2) Compliance with SDMP Commitments
  if (exec.complianceWithSdmpCommitments) {
    const sdmp = exec.complianceWithSdmpCommitments;
    allRows.push({
      requirement: 'Compliance with SDMP Commitments',
      complied: sdmp.complied,
      remarks: sdmp.remarks || '',
    });
  }

  // 3) Complaints Management
  if (exec.complaintsManagement) {
    const cm = exec.complaintsManagement;
    allRows.push({
      requirement: 'Complaints Management',
      complied: cm.naForAll, // Parent compliance check
      remarks: cm.remarks || '',
      subRows: [
        {
          requirement: 'Complaint Receiving Setup',
          complied: cm.complaintReceivingSetup,
          remarks: '',
        },
        {
          requirement: 'Case Investigation',
          complied: cm.caseInvestigation,
          remarks: '',
        },
        {
          requirement: 'Implementation of Control',
          complied: cm.implementationOfControl,
          remarks: '',
        },
        {
          requirement: 'Communication with Complainant/Public',
          complied: cm.communicationWithComplainantOrPublic,
          remarks: '',
        },
        {
          requirement: 'Complaint Documentation',
          complied: cm.complaintDocumentation,
          remarks: '',
        },
      ],
    });
  }

  // 4) Accountability
  if (exec.accountability) {
    const acc = exec.accountability;
    allRows.push({
      requirement:
        'Accountability - qualified personnel are charged with the routine monitoring of the project activities in terms of education, training, knowledge and experience of the environmental team.',
      complied: acc.complied,
      remarks: acc.remarks || '',
    });
  }

  // 5) Others
  if (exec.others) {
    const oth = exec.others;
    allRows.push({
      requirement: 'Others, please specify',
      complied: oth.na,
      remarks: oth.specify || '',
      isOthersMerged: true, // Always merge Y+N for "Others"
      showNA: oth.na === true, // Show "N/A" text when na is true
    });
  }

  // Render the table
  let y = doc.y;
  y = drawHeader(y);

  for (const row of allRows) {
    if (row.subRows && row.subRows.length > 0) {
      const parentReqWidth = reqWidth * 0.3;
      const subReqWidth = reqWidth * 0.7;

      const subRows = row.subRows;
      const subRowMinHeight = 15; // Smaller min height for sub-rows
      const subRowHeights = subRows.map((subRow) => {
        const reqTextHeight = doc.heightOfString(subRow.requirement, {
          width: subReqWidth - 10,
        });
        // Remarks are not in subrows, so we don't need to calculate their height here
        return Math.max(subRowMinHeight, reqTextHeight) + 2; // Reduced padding
      });
      const totalSubRowHeight = subRowHeights.reduce((a, b) => a + b, 0);

      // --- Draw Merged Parent Cells ---
      doc.strokeColor('#000000').lineWidth(0.5);

      // Merged "Requirement" cell (parent label)
      doc
        .moveTo(left, y)
        .lineTo(left, y + totalSubRowHeight)
        .stroke(); // Left border
      doc
        .moveTo(left + parentReqWidth, y)
        .lineTo(left + parentReqWidth, y + totalSubRowHeight)
        .stroke(); // Right border

      const parentTextHeight = doc.heightOfString(row.requirement, {
        width: parentReqWidth - 10,
      });
      const parentTextY = y + (totalSubRowHeight - parentTextHeight) / 2;
      doc.font('Helvetica').text(row.requirement, left + 5, parentTextY, {
        width: parentReqWidth - 10,
        align: 'center',
      });
      doc.font('Helvetica');

      // Merged "Remarks" cell
      doc
        .moveTo(remarksX, y)
        .lineTo(remarksX, y + totalSubRowHeight)
        .stroke(); // Left border
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + totalSubRowHeight)
        .stroke(); // Right border

      const remarksTextHeight = doc.heightOfString(row.remarks, {
        width: remarksWidth - 10,
      });
      const remarksTextY = y + (totalSubRowHeight - remarksTextHeight) / 2;
      doc.text(row.remarks, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });

      // --- Draw the sub-rows ---
      let currentY = y;

      // Check if this is "Complaints Management" with naForAll = true
      const isComplaintsNA =
        row.requirement === 'Complaints Management' && row.complied === true;

      // If naForAll is true, draw merged Y+N columns with "N/A" text
      if (isComplaintsNA) {
        // Draw merged complied columns (Y+N) for the entire group
        const compliedMergedWidth = yWidth + nWidth;

        // Draw vertical borders for merged complied area
        doc
          .moveTo(yX, y)
          .lineTo(yX, y + totalSubRowHeight)
          .stroke(); // Left border of merged Y+N
        doc
          .moveTo(remarksX, y)
          .lineTo(remarksX, y + totalSubRowHeight)
          .stroke(); // Right border of merged Y+N

        // Draw "N/A" text centered in merged Y+N area
        const naText = 'N/A';
        const naTextHeight = doc.heightOfString(naText, {
          width: compliedMergedWidth - 10,
        });
        const naTextY = y + (totalSubRowHeight - naTextHeight) / 2;
        doc.font('Helvetica').text(naText, yX + 5, naTextY, {
          width: compliedMergedWidth - 10,
          align: 'center',
        });
      }

      for (let i = 0; i < subRows.length; i++) {
        const subRow = subRows[i];
        const subRowHeight = subRowHeights[i];

        // Draw sub-row content
        const subReqX = left + parentReqWidth;

        // Borders
        doc.moveTo(subReqX, currentY).lineTo(yX, currentY).stroke(); // Top border of sub-row's requirement cell
        doc
          .moveTo(subReqX, currentY)
          .lineTo(subReqX, currentY + subRowHeight)
          .stroke(); // Left border of sub-row's requirement cell (same as parent's right)

        // Only draw vertical borders in Y+N area if NOT naForAll
        if (!isComplaintsNA) {
          doc
            .moveTo(yX, currentY)
            .lineTo(yX, currentY + subRowHeight)
            .stroke(); // Right border of sub-row's requirement cell
          doc
            .moveTo(nX, currentY)
            .lineTo(nX, currentY + subRowHeight)
            .stroke(); // Right border of Y cell
          doc
            .moveTo(remarksX, currentY)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke(); // Right border of N cell
        } else {
          // For naForAll, only draw the right border of the remarks column
          doc
            .moveTo(remarksX, currentY)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke(); // Right border of merged Y+N cell
        }

        // Bottom border for the sub-row (only under requirement area, not Y+N area when naForAll)
        if (!isComplaintsNA) {
          doc
            .moveTo(subReqX, currentY + subRowHeight)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke();
        } else {
          // Only draw bottom border under requirement column when naForAll
          doc
            .moveTo(subReqX, currentY + subRowHeight)
            .lineTo(yX, currentY + subRowHeight)
            .stroke();
        }

        // Text for sub-row requirement
        const reqTextHeight = doc.heightOfString(subRow.requirement, {
          width: subReqWidth - 10,
        });
        const reqTextY = currentY + (subRowHeight - reqTextHeight) / 2;
        doc.text(subRow.requirement, subReqX + 5, reqTextY, {
          width: subReqWidth - 10,
          align: 'left',
        });

        // Checkmark for sub-row (only if not naForAll)
        if (!isComplaintsNA && subRow.complied === true) {
          const checkmarkSize = 4;
          const centerX = yX + yWidth / 2;
          const centerY = currentY + subRowHeight / 2;
          doc
            .save()
            .lineWidth(1.2)
            .moveTo(centerX - checkmarkSize, centerY)
            .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
            .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
            .stroke()
            .restore();
        }

        // Checkmark in N column for sub-row if false (only if not naForAll)
        if (!isComplaintsNA && subRow.complied === false) {
          const checkmarkSize = 4;
          const centerX = nX + nWidth / 2;
          const centerY = currentY + subRowHeight / 2;
          doc
            .save()
            .lineWidth(1.2)
            .moveTo(centerX - checkmarkSize, centerY)
            .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
            .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
            .stroke()
            .restore();
        }

        currentY += subRowHeight;
      }
      // Final bottom border for the entire group
      doc
        .moveTo(left, y + totalSubRowHeight)
        .lineTo(left + tableWidth, y + totalSubRowHeight)
        .stroke();

      y = currentY;
    } else {
      y = drawRow(y, row.requirement, row.complied, row.remarks, {
        isOthersMerged: row.isOthersMerged,
        showNA: row.showNA,
      });
    }
  }

  doc.y = y;
  doc.moveDown(1);
}

/**
 * Draw "Process Documentation of Activities Undertaken" section with a table.
 * Table structure:
 *   Header: Activities | Date Conducted | MMT Members Involved | Methodology/ Other Remarks
 *   First row after header: "Document Review of:" (merged across all columns)
 *   Then activity rows with members displayed vertically within cells
 */
export function drawProcessDocumentationOfActivitiesUndertaken(
  doc: PDFKit.PDFDocument,
  process: NonNullable<
    CMVRGeneralInfo['processDocumentationOfActivitiesUndertaken']
  >,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Column widths
  const activitiesWidth = tableWidth * 0.22;
  const dateWidth = tableWidth * 0.15;
  const membersWidth = tableWidth * 0.3;
  const remarksWidth = tableWidth * 0.27;

  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get column X positions
  const activitiesX = left;
  const dateX = left + activitiesWidth;
  const membersX = dateX + dateWidth;
  const remarksX = membersX + membersWidth;

  // Calculate dynamic header height based on text wrapping
  const calculateHeaderHeight = (): number => {
    doc.font('Helvetica-Bold').fontSize(11);
    const headers = [
      { text: 'Activities', width: activitiesWidth },
      { text: 'Date Conducted', width: dateWidth },
      { text: 'MMT Members Involved', width: membersWidth },
      { text: 'Methodology/ Other Remarks', width: remarksWidth },
    ];

    const headerTextHeights = headers.map((h) =>
      doc.heightOfString(h.text, {
        width: h.width - 10,
        align: 'center',
      }),
    );

    return Math.max(20, ...headerTextHeights) + 8; // Minimum 20px + 8px padding
  };

  const headerHeight = calculateHeaderHeight();

  // Helper to draw the header
  const drawHeader = (y: number) => {
    doc
      .strokeColor('#000000')
      .lineWidth(0.5)
      .font('Helvetica-Bold')
      .fontSize(11);

    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + headerHeight)
      .stroke();
    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + headerHeight)
      .stroke();

    // Vertical dividers
    doc
      .moveTo(dateX, y)
      .lineTo(dateX, y + headerHeight)
      .stroke();
    doc
      .moveTo(membersX, y)
      .lineTo(membersX, y + headerHeight)
      .stroke();
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + headerHeight)
      .stroke();

    // Bottom border
    doc
      .moveTo(left, y + headerHeight)
      .lineTo(left + tableWidth, y + headerHeight)
      .stroke();

    // Draw header texts
    const headers = [
      { text: 'Activities', x: activitiesX, width: activitiesWidth },
      { text: 'Date Conducted', x: dateX, width: dateWidth },
      { text: 'MMT Members Involved', x: membersX, width: membersWidth },
      {
        text: 'Methodology/ Other Remarks',
        x: remarksX,
        width: remarksWidth,
      },
    ];

    headers.forEach((header) => {
      const textHeight = doc.heightOfString(header.text, {
        width: header.width - 10,
      });
      const textY = y + (headerHeight - textHeight) / 2;
      doc.text(header.text, header.x + 5, textY, {
        width: header.width - 10,
        align: 'center',
      });
    });

    return y + headerHeight;
  };

  // Helper to draw the "Document Review of:" merged row
  const drawDocumentReviewRow = (y: number) => {
    doc.font('Helvetica-Bold').fontSize(11);
    const rowHeight = 18;

    // Check page break
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica-Bold').fontSize(11);
    }

    // Draw borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Right
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Bottom

    // Draw text
    const text = 'Document Review of:';
    const textHeight = doc.heightOfString(text, { width: tableWidth - 10 });
    const textY = y + (rowHeight - textHeight) / 2;
    doc.font('Helvetica');
    doc.text(text, left + 5, textY, {
      width: tableWidth - 10,
      align: 'left',
    });

    return y + rowHeight;
  };

  // Helper to draw an activity row with sub-rows for each member
  const drawActivityRowWithSubRows = (
    y: number,
    activityName: string,
    date: string,
    members: string[],
    remarks: string,
    options?: {
      remarksMode?: 'activity' | 'perMember' | 'none';
    },
  ) => {
    const remarksMode = options?.remarksMode ?? 'activity';
    doc.font('Helvetica').fontSize(11);

    const minSubRowHeight = 16; // Minimum height for each member sub-row

    // Calculate individual heights for each member
    const memberHeights = members.map((member) => {
      // Split member string by " - " to separate name and role
      const parts = member.split(' - ');
      const name = parts[0];
      const role = parts.length > 1 ? parts.slice(1).join(' - ') : '';

      // Calculate height for bold name
      doc.font('Helvetica-Bold').fontSize(11);
      const nameHeight = doc.heightOfString(name, {
        width: membersWidth - 10,
      });

      // Calculate height for regular role (if exists)
      let roleHeight = 0;
      if (role) {
        doc.font('Helvetica').fontSize(11);
        roleHeight = doc.heightOfString(role, {
          width: membersWidth - 10,
        });
      }

      const totalTextHeight = nameHeight + roleHeight;
      return Math.max(minSubRowHeight, totalTextHeight + 6); // Add padding
    });

    // Calculate total height needed from members
    const totalMemberRowsHeight = memberHeights.reduce((sum, h) => sum + h, 0);

    // Also consider the height of the activity name itself, as it might wrap
    const activityNameHeight = doc.heightOfString(activityName, {
      width: activitiesWidth - 10,
    });

    // The total height is the max of the height required by members and the height required by the activity name
    const totalSubRowsHeight = Math.max(
      totalMemberRowsHeight,
      activityNameHeight + 6, // Add padding to match member rows
    );

    // Check page break
    if (y + totalSubRowsHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica').fontSize(11);
    }

    // Draw merged cells for Activity Name, Date, and Remarks
    doc.strokeColor('#000000').lineWidth(0.5);

    // Left border (Activity column)
    doc
      .moveTo(left, y)
      .lineTo(left, y + totalSubRowsHeight)
      .stroke();

    // Right border of Activity column
    doc
      .moveTo(dateX, y)
      .lineTo(dateX, y + totalSubRowsHeight)
      .stroke();

    // Right border of Date column
    doc
      .moveTo(membersX, y)
      .lineTo(membersX, y + totalSubRowsHeight)
      .stroke();

    // Right border of Members column
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + totalSubRowsHeight)
      .stroke();

    // Right edge (end of Remarks column)
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + totalSubRowsHeight)
      .stroke();

    // Bottom border - avoid drawing across merged remarks column when not rendering per member
    doc
      .moveTo(left, y + totalSubRowsHeight)
      .lineTo(remarksX, y + totalSubRowsHeight)
      .stroke();

    if (remarksMode !== 'none') {
      doc
        .moveTo(remarksX, y + totalSubRowsHeight)
        .lineTo(left + tableWidth, y + totalSubRowsHeight)
        .stroke();
    }

    // Draw Activity Name (vertically centered in merged cell)
    const activityTextHeight = doc.heightOfString(activityName, {
      width: activitiesWidth - 10,
    });
    const activityTextY = y + (totalSubRowsHeight - activityTextHeight) / 2;
    doc.text(activityName, activitiesX + 5, activityTextY, {
      width: activitiesWidth - 10,
      align: 'left',
    });

    // Always draw merged Date cell (one date per activity)
    const dateTextHeight = doc.heightOfString(date, {
      width: dateWidth - 10,
    });
    const dateTextY = y + (totalSubRowsHeight - dateTextHeight) / 2;
    doc.text(date, dateX + 5, dateTextY, {
      width: dateWidth - 10,
      align: 'center',
    });

    // Draw merged Remarks cell for entire activity
    if (remarksMode === 'activity') {
      const remarksTextHeight = doc.heightOfString(remarks, {
        width: remarksWidth - 10,
      });
      const remarksTextY = y + (totalSubRowsHeight - remarksTextHeight) / 2;
      doc.text(remarks, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });
    }

    // Draw sub-rows for each member
    let currentY = y;
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      const currentSubRowHeight = memberHeights[i];

      // Draw horizontal line between sub-rows (except for the first one)
      // Only draw between members column and remarks column (not through date column)
      if (i > 0) {
        if (remarksMode === 'activity' || remarksMode === 'none') {
          // When remarks are merged, only draw line in members column
          doc.moveTo(membersX, currentY).lineTo(remarksX, currentY).stroke();
        } else {
          // When remarks are not merged, draw line through members and remarks
          doc
            .moveTo(membersX, currentY)
            .lineTo(left + tableWidth, currentY)
            .stroke();
        }
      }

      // Split member string by " - " to separate name and role
      const parts = member.split(' - ');
      const name = parts[0];
      const role = parts.length > 1 ? parts.slice(1).join(' - ') : '';

      // Calculate heights for vertical centering
      doc.font('Helvetica-Bold').fontSize(11);
      const nameHeight = doc.heightOfString(name, {
        width: membersWidth - 10,
      });

      let roleHeight = 0;
      if (role) {
        doc.font('Helvetica').fontSize(11);
        roleHeight = doc.heightOfString(role, {
          width: membersWidth - 10,
        });
      }

      const totalTextHeight = nameHeight + roleHeight;
      const startY = currentY + (currentSubRowHeight - totalTextHeight) / 2;

      // Draw member name in bold
      doc.font('Helvetica-Bold').fontSize(11);
      doc.text(name, membersX + 5, startY, {
        width: membersWidth - 10,
        align: 'center',
        continued: false,
      });

      // Draw role in regular font on next line (if exists)
      if (role) {
        doc.font('Helvetica').fontSize(11);
        doc.text(role, membersX + 5, startY + nameHeight, {
          width: membersWidth - 10,
          align: 'center',
          continued: false,
        });
      }

      // Draw remarks per member when requested
      if (remarksMode === 'perMember') {
        // Remarks cell (use activity remarks)
        const remarksTextHeight = doc.heightOfString(remarks, {
          width: remarksWidth - 10,
        });
        const remarksTextY =
          currentY + (currentSubRowHeight - remarksTextHeight) / 2;
        doc.text(remarks, remarksX + 5, remarksTextY, {
          width: remarksWidth - 10,
          align: 'center',
        });
      }

      currentY += currentSubRowHeight;
    }

    return y + totalSubRowsHeight;
  };

  // Build activity rows
  const activities = process.activities;
  const globalDate = process.dateConducted || '';
  const globalRemarksText =
    (process.mergedMethodologyOrOtherRemarks ?? '').trim() || 'N/A';
  const useSameDate = process.sameDateForAllActivities;

  const activityRows: Array<{
    name: string;
    date: string;
    members: string[];
    remarks: string;
    remarksMode?: 'activity' | 'perMember' | 'none';
  }> = [];

  // if (activities?.complianceWithEccConditionsCommitments) {
  //   const activity = activities.complianceWithEccConditionsCommitments;
  //   activityRows.push({
  //     name: 'Compliance with ECC Conditions/ Commitments',
  //     date: useSameDate ? globalDate : activity.dateConducted || globalDate,
  //     members: activity.mmtMembersInvolved || [],
  //     remarks: activity.remarks || '',
  //     remarksMode: 'none',
  //   });
  // }

  // if (activities?.complianceWithEpepAepepConditions) {
  //   const activity = activities.complianceWithEpepAepepConditions;
  //   activityRows.push({
  //     name: 'Compliance with EPEP/ AEPEP Conditions',
  //     date: useSameDate ? globalDate : activity.dateConducted || globalDate,
  //     members: activity.mmtMembersInvolved || [],
  //     remarks: activity.remarks || '',
  //     remarksMode: 'none',
  //   });
  // }

  // if (activities?.siteOcularValidation) {
  //   const activity = activities.siteOcularValidation;
  //   activityRows.push({
  //     name: 'Site Ocular/ Validation',
  //     date: useSameDate ? globalDate : activity.dateConducted || globalDate,
  //     members: activity.mmtMembersInvolved || [],
  //     remarks: activity.remarks || '',
  //     remarksMode: 'none',
  //   });
  // }

  if (activities?.siteValidationConfirmatorySampling) {
    const activity = activities.siteValidationConfirmatorySampling;
    if (activity.applicable === false || activity.none === true) {
      activityRows.push({
        name: 'Site Validation/ Confirmatory Sampling',
        date: 'N/A',
        members: ['None'],
        remarks: activity.remarks || '',
        remarksMode: 'none',
      });
    } else {
      activityRows.push({
        name: 'Site Validation/ Confirmatory Sampling',
        date: useSameDate ? globalDate : activity.dateConducted || globalDate,
        members: activity.mmtMembersInvolved || [],
        remarks: activity.remarks || '',
        remarksMode: 'none',
      });
    }
  }

  // Render the table
  let y = doc.y;
  y = drawHeader(y);
  y = drawDocumentReviewRow(y);

  let remarksColumnStartY: number | null = null;

  for (const row of activityRows) {
    if (remarksColumnStartY === null) {
      remarksColumnStartY = y;
    }
    const remarksMode = row.remarksMode ?? 'none';
    y = drawActivityRowWithSubRows(
      y,
      row.name,
      row.date,
      row.members,
      row.remarks,
      { remarksMode },
    );
  }

  if (remarksColumnStartY !== null) {
    const remarksColumnHeight = y - remarksColumnStartY;
    if (remarksColumnHeight > 0) {
      doc.font('Helvetica').fontSize(11);
      const remarksTextHeight = doc.heightOfString(globalRemarksText, {
        width: remarksWidth - 10,
        align: 'center',
      });
      const remarksTextY =
        remarksColumnStartY +
        Math.max(0, (remarksColumnHeight - remarksTextHeight) / 2);

      // Draw enclosing borders for merged remarks column
      doc.moveTo(remarksX, remarksColumnStartY);
      doc.lineTo(remarksX, y).stroke();

      doc.moveTo(left + tableWidth, remarksColumnStartY);
      doc.lineTo(left + tableWidth, y).stroke();

      // Top border (connect to previous section)
      doc.moveTo(remarksX, remarksColumnStartY);
      doc.lineTo(left + tableWidth, remarksColumnStartY).stroke();

      // Bottom border of merged column
      doc.moveTo(remarksX, y);
      doc.lineTo(left + tableWidth, y).stroke();

      doc.text(globalRemarksText, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });
    }
  }

  doc.y = y;
  doc.moveDown(1);
}

/**
 * Draw Compliance to Project Location and Coverage Limits table
 * 5 columns: Parameter | Specification | W/in Specs? (Y/N) | Remarks
 */
export function drawComplianceToProjectLocationTable(
  doc: PDFKit.PDFDocument,
  data: {
    parameters?: Array<{
      name?: string;
      specification?: string | Record<string, string | undefined>;
      withinSpecs?: boolean;
      remarks?: string | Record<string, string | undefined>;
    }>;
    otherComponents?: Array<{
      specification?: string;
      withinSpecs?: boolean;
      remarks?: string;
    }>;
  },
): void {
  if (!data || (!data.parameters && !data.otherComponents)) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Column widths: Parameter 20%, Specification 35%, W/in Specs Y 8%, W/in Specs N 8%, Remarks 29%
  const colWidths = [
    tableWidth * 0.2, // Parameter
    tableWidth * 0.35, // Specification
    tableWidth * 0.08, // Y
    tableWidth * 0.08, // N
    tableWidth * 0.29, // Remarks
  ];

  const rowMinHeight = 14;
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get X position for a column
  const getColX = (colIndex: number): number => {
    return left + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0);
  };

  let y = doc.y;

  const headerRow1Height = 20;
  const headerRow2Height = 30;
  const totalHeaderHeight = headerRow1Height + headerRow2Height;

  // Helper function to draw the complex header
  const drawHeader = (yPos: number) => {
    doc
      .font('Helvetica-Bold')
      .fontSize(11)
      .strokeColor('#000000')
      .lineWidth(0.5);

    // --- Draw Borders ---
    // Outer borders
    doc
      .moveTo(left, yPos)
      .lineTo(left + tableWidth, yPos)
      .stroke(); // Top
    doc
      .moveTo(left, yPos)
      .lineTo(left, yPos + totalHeaderHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, yPos)
      .lineTo(left + tableWidth, yPos + totalHeaderHeight)
      .stroke(); // Right
    doc
      .moveTo(left, yPos + totalHeaderHeight)
      .lineTo(left + tableWidth, yPos + totalHeaderHeight)
      .stroke(); // Bottom

    // Main vertical dividers (spanning both rows)
    doc
      .moveTo(getColX(1), yPos)
      .lineTo(getColX(1), yPos + totalHeaderHeight)
      .stroke(); // After Parameter
    doc
      .moveTo(getColX(2), yPos)
      .lineTo(getColX(2), yPos + totalHeaderHeight)
      .stroke(); // After Specification
    doc
      .moveTo(getColX(4), yPos)
      .lineTo(getColX(4), yPos + totalHeaderHeight)
      .stroke(); // After W/in Specs block (before Remarks)

    // Horizontal divider inside W/in Specs?
    doc
      .moveTo(getColX(2), yPos + headerRow1Height)
      .lineTo(getColX(4), yPos + headerRow1Height)
      .stroke();

    // Vertical divider between Y and N (only in second row)
    doc
      .moveTo(getColX(3), yPos + headerRow1Height)
      .lineTo(getColX(3), yPos + totalHeaderHeight)
      .stroke();

    // --- Draw Text ---
    // Merged Row Headers (Parameter, Specification, Remarks)
    const mergedHeaders = [
      { text: 'Parameter', colIndex: 0 },
      { text: 'Specification', colIndex: 1 },
      {
        text: 'Remarks  Description of Actual Implementation ',
        colIndex: 4,
      },
    ];

    for (const header of mergedHeaders) {
      const textHeight = doc.heightOfString(header.text, {
        width: colWidths[header.colIndex] - 10,
        align: 'center',
      });
      const textY = yPos + (totalHeaderHeight - textHeight) / 2;
      doc.text(header.text, getColX(header.colIndex) + 5, textY, {
        width: colWidths[header.colIndex] - 10,
        align: 'center',
      });
    }

    // W/in Specs? (Row 1)
    const wInSpecsText = 'W/in Specs?';
    const wInSpecsWidth = colWidths[2] + colWidths[3];
    const wInSpecsTextHeight = doc.heightOfString(wInSpecsText, {
      width: wInSpecsWidth - 10,
      align: 'center',
    });
    const wInSpecsTextY = yPos + (headerRow1Height - wInSpecsTextHeight) / 2;
    doc.text(wInSpecsText, getColX(2) + 5, wInSpecsTextY, {
      width: wInSpecsWidth - 10,
      align: 'center',
    });

    // Y (Row 2)
    const yText = 'Y';
    const yTextHeight = doc.heightOfString(yText, {
      width: colWidths[2] - 10,
      align: 'center',
    });
    const yTextY =
      yPos + headerRow1Height + (headerRow2Height - yTextHeight) / 2;
    doc.text(yText, getColX(2) + 5, yTextY, {
      width: colWidths[2] - 10,
      align: 'center',
    });

    // N (Row 2)
    const nText = 'N';
    const nTextHeight = doc.heightOfString(nText, {
      width: colWidths[3] - 10,
      align: 'center',
    });
    const nTextY =
      yPos + headerRow1Height + (headerRow2Height - nTextHeight) / 2;
    doc.text(nText, getColX(3) + 5, nTextY, {
      width: colWidths[3] - 10,
      align: 'center',
    });

    return yPos + totalHeaderHeight;
  };

  y = drawHeader(y);

  // Data rows
  doc.font('Helvetica').fontSize(11);

  const rows: Array<{
    parameter: string;
    specification: string | Record<string, string | undefined>;
    withinSpecs: boolean;
    remarks: string | Record<string, string | undefined>;
    hasSubRows: boolean;
  }> = [];

  // Add parameters
  if (data.parameters) {
    for (const param of data.parameters) {
      const hasSubSpec =
        typeof param.specification === 'object' && param.specification !== null;
      const hasSubRemarks =
        typeof param.remarks === 'object' && param.remarks !== null;
      rows.push({
        parameter: param.name || '',
        specification: param.specification || '',
        withinSpecs: param.withinSpecs ?? false,
        remarks: param.remarks || '',
        hasSubRows: hasSubSpec || hasSubRemarks,
      });
    }
  }

  // Add otherComponents
  if (data.otherComponents) {
    for (const comp of data.otherComponents) {
      rows.push({
        parameter: 'Other Components',
        specification: comp.specification || '',
        withinSpecs: comp.withinSpecs ?? false,
        remarks: comp.remarks || '',
        hasSubRows: false,
      });
    }
  }

  for (const row of rows) {
    if (row.hasSubRows) {
      // Handle rows with sub-specifications
      const specEntries =
        typeof row.specification === 'object'
          ? Object.entries(row.specification)
          : [];

      // Calculate heights for each sub-row
      const subRowHeights: number[] = [];
      const maxSubRows = specEntries.length;

      // Helper function to format text with bullets
      const formatWithBullets = (text: string): string => {
        // Split by semicolons or existing bullet points (not commas to preserve sentences)
        const items = text
          .split(/;|/)
          .map((item) => item.trim())
          .filter((item) => item.length > 0);

        // If there's only one item or text is very short, return as is
        if (items.length <= 1 || text.length < 50) {
          return text;
        }

        // Join with bullets (using simple bullet that will render)
        return items.map((item) => ` ${item}`).join('\n');
      };

      for (let i = 0; i < maxSubRows; i++) {
        const specEntry = specEntries[i];

        let specHeight = 0;
        if (specEntry) {
          const [key, value] = specEntry;
          const specText = formatWithBullets(value || '');
          const keyLabel =
            key.charAt(0).toUpperCase() +
            key.slice(1) +
            (key.includes(':') ? '' : ':');

          // Calculate label height
          const labelHeight = doc.heightOfString(keyLabel, {
            width: colWidths[1] - 10,
            align: 'center',
          });

          // Calculate text height (use left alignment for bullets)
          const textHeight = doc.heightOfString(specText, {
            width: colWidths[1] - 10,
            align: 'left',
          });

          // Total height includes label + line spacing + text
          specHeight = labelHeight + 4 + textHeight;
        }

        subRowHeights.push(Math.max(rowMinHeight, specHeight) + 10);
      }

      const totalRowHeight = subRowHeights.reduce((sum, h) => sum + h, 0);

      // Page break if needed
      if (y + totalRowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        y = drawHeader(y);
        doc.font('Helvetica').fontSize(11);
      }

      // Draw merged Parameter column
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + totalRowHeight)
        .stroke();
      doc
        .moveTo(getColX(1), y)
        .lineTo(getColX(1), y + totalRowHeight)
        .stroke();

      const paramTextHeight = doc.heightOfString(row.parameter, {
        width: colWidths[0] - 10,
        align: 'center',
      });
      const paramTextY = y + (totalRowHeight - paramTextHeight) / 2;
      doc.text(row.parameter, getColX(0) + 5, paramTextY, {
        width: colWidths[0] - 10,
        align: 'center',
      });

      // Draw merged W/in Specs columns
      doc
        .moveTo(getColX(2), y)
        .lineTo(getColX(2), y + totalRowHeight)
        .stroke();
      doc
        .moveTo(getColX(3), y)
        .lineTo(getColX(3), y + totalRowHeight)
        .stroke();
      doc
        .moveTo(getColX(4), y)
        .lineTo(getColX(4), y + totalRowHeight)
        .stroke();

      // Draw checkmark in merged W/in Specs area
      if (row.withinSpecs) {
        const checkmarkSize = 4;
        const centerX = getColX(2) + colWidths[2] / 2;
        const centerY = y + totalRowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      } else {
        const checkmarkSize = 4;
        const centerX = getColX(3) + colWidths[3] / 2;
        const centerY = y + totalRowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      // Render remarks as merged cell (always, whether string or object)
      let remarksText = '';
      if (typeof row.remarks === 'string') {
        remarksText = formatWithBullets(row.remarks);
      } else if (typeof row.remarks === 'object' && row.remarks !== null) {
        // If remarks is an object, concatenate all values
        remarksText = Object.values(row.remarks)
          .filter((val) => val)
          .map((val) => formatWithBullets(val as string))
          .join('\n\n');
      }

      if (remarksText.length > 0) {
        const remarksTextHeight = doc.heightOfString(remarksText, {
          width: colWidths[4] - 10,
          align: 'left',
        });
        const remarksTextY = y + (totalRowHeight - remarksTextHeight) / 2;
        doc.font('Helvetica').fontSize(11);
        doc.text(remarksText, getColX(4) + 5, remarksTextY, {
          width: colWidths[4] - 10,
          align: 'left',
        });
      }

      // Draw sub-rows
      let currentY = y;
      for (let i = 0; i < maxSubRows; i++) {
        const subRowHeight = subRowHeights[i];
        const specEntry = specEntries[i];

        // Draw horizontal divider only in Specification column (except for first row)
        if (i > 0) {
          doc
            .moveTo(getColX(1), currentY)
            .lineTo(getColX(2), currentY)
            .stroke();
        }

        // Specification sub-row
        if (specEntry) {
          const [key, value] = specEntry;
          const specText = formatWithBullets(value || '');

          // Format the key as a label (capitalize first letter, add colon if not present)
          const keyLabel =
            key.charAt(0).toUpperCase() +
            key.slice(1) +
            (key.includes(':') ? '' : ':');

          // Calculate label height
          const labelHeight = doc.heightOfString(keyLabel, {
            width: colWidths[1] - 10,
            align: 'center',
          });

          // Calculate text height
          const textHeight = doc.heightOfString(specText, {
            width: colWidths[1] - 10,
            align: 'left',
          });

          // Calculate total content height and position
          const totalContentHeight = labelHeight + 4 + textHeight;
          const startY = currentY + (subRowHeight - totalContentHeight) / 2;

          // Draw label in bold, centered
          doc.font('Helvetica-Bold').fontSize(10);
          doc.text(keyLabel, getColX(1) + 5, startY, {
            width: colWidths[1] - 10,
            align: 'center',
            continued: false,
          });

          // Draw horizontal line below label (full width)
          const lineY = startY + labelHeight + 2;
          doc
            .strokeColor('#000000')
            .lineWidth(0.5)
            .moveTo(getColX(1), lineY)
            .lineTo(getColX(1) + colWidths[1], lineY)
            .stroke();

          // Draw value in regular font, left-aligned
          doc.font('Helvetica').fontSize(11);
          doc.text(specText, getColX(1) + 5, lineY + 2, {
            width: colWidths[1] - 10,
            align: 'left',
          });
        }

        currentY += subRowHeight;
      }

      // Draw bottom border and right edge
      doc
        .moveTo(left, y + totalRowHeight)
        .lineTo(left + tableWidth, y + totalRowHeight)
        .stroke();
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + totalRowHeight)
        .stroke();

      y += totalRowHeight;
    } else {
      // Simple row without sub-specifications
      const specText =
        typeof row.specification === 'string' ? row.specification : '';
      const remarksText = typeof row.remarks === 'string' ? row.remarks : '';

      const paramHeight = doc.heightOfString(row.parameter, {
        width: colWidths[0] - 10,
        align: 'center',
      });
      const specHeight = doc.heightOfString(specText, {
        width: colWidths[1] - 10,
        align: 'center',
      });
      const remarksHeight = doc.heightOfString(remarksText, {
        width: colWidths[4] - 10,
        align: 'center',
      });
      const rowHeight =
        Math.max(rowMinHeight, paramHeight, specHeight, remarksHeight) + 6;

      // Page break if needed
      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        y = drawHeader(y);
        doc.font('Helvetica').fontSize(11);
      }

      // Draw row borders
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + rowHeight)
        .stroke();

      for (let i = 1; i <= 4; i++) {
        doc
          .moveTo(getColX(i), y)
          .lineTo(getColX(i), y + rowHeight)
          .stroke();
      }

      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      // Draw cell content
      const paramTextHeight = doc.heightOfString(row.parameter, {
        width: colWidths[0] - 10,
        align: 'center',
      });
      const paramTextY = y + (rowHeight - paramTextHeight) / 2;
      doc.text(row.parameter, getColX(0) + 5, paramTextY, {
        width: colWidths[0] - 10,
        align: 'center',
      });

      const specTextHeight = doc.heightOfString(specText, {
        width: colWidths[1] - 10,
        align: 'center',
      });
      const specTextY = y + (rowHeight - specTextHeight) / 2;
      doc.text(specText, getColX(1) + 5, specTextY, {
        width: colWidths[1] - 10,
        align: 'center',
      });

      // Draw checkmark
      if (row.withinSpecs) {
        const checkmarkSize = 4;
        const centerX = getColX(2) + colWidths[2] / 2;
        const centerY = y + rowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      } else {
        const checkmarkSize = 4;
        const centerX = getColX(3) + colWidths[3] / 2;
        const centerY = y + rowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      const remarksTextHeight = doc.heightOfString(remarksText, {
        width: colWidths[4] - 10,
        align: 'center',
      });
      const remarksTextY = y + (rowHeight - remarksTextHeight) / 2;
      doc.text(remarksText, getColX(4) + 5, remarksTextY, {
        width: colWidths[4] - 10,
        align: 'center',
      });

      y += rowHeight;
    }
  }

  doc.y = y;
  doc.moveDown(0.5);
}

/**
 * Draw Compliance to Impact Management Commitments table
 */
export function drawComplianceToImpactManagementCommitmentsTable(
  doc: PDFKit.PDFDocument,
  data: {
    constructionInfo?: Array<{
      areaName?: string;
      commitments?: Array<{
        plannedMeasure?: string;
        actualObservation?: string;
        isEffective?: boolean | null;
        recommendations?: string;
      }>;
    }>;
    implementationOfEnvironmentalImpactControlStrategies?: Array<{
      areaName?: string;
      commitments?: Array<{
        plannedMeasure?: string;
        actualObservation?: string;
        isEffective?: boolean | null;
        recommendations?: string;
      }>;
    }>;
    overallComplianceAssessment?: string;
  },
): void {
  if (!data) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Column widths: Project Impacts 20%, Planned 20%, Actual Observation 20%, Y 8%, N 8%, Recommendations 24%
  const colWidths = [
    tableWidth * 0.17, // Project Impacts
    tableWidth * 0.25, // Planned
    tableWidth * 0.21, // Actual Observation
    tableWidth * 0.065, // Y
    tableWidth * 0.065, // N
    tableWidth * 0.24, // Recommendations
  ];

  const rowMinHeight = 14;
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get X position for a column
  const getColX = (colIndex: number): number => {
    return left + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0);
  };

  let y = doc.y;

  // Draw header
  const drawHeader = (yPos: number): number => {
    const headerRow1Height = 20; // Increased from 20 to 25
    const headerRow2Height = 30;
    const totalHeaderHeight = headerRow1Height + headerRow2Height;

    doc
      .font('Helvetica-Bold')
      .fontSize(11)
      .strokeColor('#000000')
      .lineWidth(0.5);

    // --- Draw Borders ---
    // Outer borders
    doc
      .moveTo(left, yPos)
      .lineTo(left + tableWidth, yPos)
      .stroke(); // Top
    doc
      .moveTo(left, yPos)
      .lineTo(left, yPos + totalHeaderHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, yPos)
      .lineTo(left + tableWidth, yPos + totalHeaderHeight)
      .stroke(); // Right
    doc
      .moveTo(left, yPos + totalHeaderHeight)
      .lineTo(left + tableWidth, yPos + totalHeaderHeight)
      .stroke(); // Bottom

    // Main vertical dividers (spanning both rows)
    doc
      .moveTo(getColX(1), yPos)
      .lineTo(getColX(1), yPos + totalHeaderHeight)
      .stroke(); // After Project Impacts
    doc
      .moveTo(getColX(3), yPos)
      .lineTo(getColX(3), yPos + totalHeaderHeight)
      .stroke(); // After Actual Observation
    doc
      .moveTo(getColX(5), yPos)
      .lineTo(getColX(5), yPos + totalHeaderHeight)
      .stroke(); // After N (before Recommendations)

    // Horizontal divider inside Mitigating Measures and Effective?
    doc
      .moveTo(getColX(1), yPos + headerRow1Height)
      .lineTo(getColX(3), yPos + headerRow1Height)
      .stroke(); // Mitigating Measures divider
    doc
      .moveTo(getColX(3), yPos + headerRow1Height)
      .lineTo(getColX(5), yPos + headerRow1Height)
      .stroke(); // Effective? divider

    // Vertical divider between Planned and Actual Observation (only in second row)
    doc
      .moveTo(getColX(2), yPos + headerRow1Height)
      .lineTo(getColX(2), yPos + totalHeaderHeight)
      .stroke();

    // Vertical divider between Y and N (only in second row)
    doc
      .moveTo(getColX(4), yPos + headerRow1Height)
      .lineTo(getColX(4), yPos + totalHeaderHeight)
      .stroke();

    // --- Draw Header Text ---
    // Row 1 merged headers (Project Impacts, Mitigating Measures, Effective?, Recommendations)
    const row1Headers = [
      { text: 'Project Impacts', colIndex: 0 },
      { text: 'Recommendations', colIndex: 5 },
    ];

    for (const header of row1Headers) {
      const textHeight = doc.heightOfString(header.text, {
        width: colWidths[header.colIndex] - 10,
        align: 'center',
      });
      const textY = yPos + (totalHeaderHeight - textHeight) / 2;
      doc.text(header.text, getColX(header.colIndex) + 5, textY, {
        width: colWidths[header.colIndex] - 10,
        align: 'center',
      });
    }

    // Mitigating Measures/ Control Strategies (Row 1, merged across cols 1-2)
    const mitigatingMeasuresText = 'Mitigating Measures/ Control Strategies';
    const mitigatingMeasuresWidth = colWidths[1] + colWidths[2];
    const mitigatingMeasuresTextHeight = doc.heightOfString(
      mitigatingMeasuresText,
      {
        width: mitigatingMeasuresWidth - 10,
        align: 'center',
      },
    );
    const mitigatingMeasuresTextY =
      yPos + (headerRow1Height - mitigatingMeasuresTextHeight) / 2;
    doc.text(mitigatingMeasuresText, getColX(1) + 5, mitigatingMeasuresTextY, {
      width: mitigatingMeasuresWidth - 10,
      align: 'center',
    });

    // Effective? (Row 1, merged across cols 3-4)
    const effectiveText = 'Effective?';
    const effectiveWidth = colWidths[3] + colWidths[4];
    const effectiveTextHeight = doc.heightOfString(effectiveText, {
      width: effectiveWidth - 10,
      align: 'center',
    });
    const effectiveTextY = yPos + (headerRow1Height - effectiveTextHeight) / 2;
    doc.text(effectiveText, getColX(3) + 5, effectiveTextY, {
      width: effectiveWidth - 10,
      align: 'center',
    });

    // Row 2 sub-headers (Planned, Actual Observation, Y, N)
    const plannedText = 'Planned';
    const plannedTextHeight = doc.heightOfString(plannedText, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const plannedTextY =
      yPos + headerRow1Height + (headerRow2Height - plannedTextHeight) / 2;
    doc.text(plannedText, getColX(1) + 5, plannedTextY, {
      width: colWidths[1] - 10,
      align: 'center',
    });

    const actualObservationText = 'Actual Observation';
    const actualObservationTextHeight = doc.heightOfString(
      actualObservationText,
      {
        width: colWidths[2] - 10,
        align: 'center',
      },
    );
    const actualObservationTextY =
      yPos +
      headerRow1Height +
      (headerRow2Height - actualObservationTextHeight) / 2;
    doc.text(actualObservationText, getColX(2) + 5, actualObservationTextY, {
      width: colWidths[2] - 10,
      align: 'center',
    });

    const yText = 'Y';
    const yTextHeight = doc.heightOfString(yText, {
      width: colWidths[3] - 10,
      align: 'center',
    });
    const yTextY =
      yPos + headerRow1Height + (headerRow2Height - yTextHeight) / 2;
    doc.text(yText, getColX(3) + 5, yTextY, {
      width: colWidths[3] - 10,
      align: 'center',
    });

    const nText = 'N';
    const nTextHeight = doc.heightOfString(nText, {
      width: colWidths[4] - 10,
      align: 'center',
    });
    const nTextY =
      yPos + headerRow1Height + (headerRow2Height - nTextHeight) / 2;
    doc.text(nText, getColX(4) + 5, nTextY, {
      width: colWidths[4] - 10,
      align: 'center',
    });

    return yPos + totalHeaderHeight;
  };

  // Initial header
  y = drawHeader(y);

  // Helper function to process an area with its commitments
  const processArea = (
    areaName: string,
    commitments: Array<{
      plannedMeasure?: string;
      actualObservation?: string;
      isEffective?: boolean | null;
      recommendations?: string;
    }>,
    useExtraPadding: boolean = false,
  ) => {
    if (commitments.length === 0) return;

    doc.font('Helvetica').fontSize(11);

    // Calculate areaName height first
    doc.font('Helvetica-Bold').fontSize(11);
    const areaNameHeight = doc.heightOfString(areaName, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    doc.font('Helvetica').fontSize(11);

    // Calculate heights for all commitment rows
    const rowHeights: number[] = [];
    for (let i = 0; i < commitments.length; i++) {
      const commitment = commitments[i];
      const isFirstRow = i === 0;

      const plannedText = commitment.plannedMeasure || '';
      const actualText = commitment.actualObservation || '';
      const recommendationsText = commitment.recommendations || '';

      // Check if plannedText already has numbering, if not add it
      const hasNumbering = /^\d+\./.test(plannedText);
      const numberedPlannedText = hasNumbering
        ? plannedText
        : plannedText
          ? `${i + 1}. ${plannedText}`
          : '';
      const plannedHeight = doc.heightOfString(numberedPlannedText, {
        width: colWidths[1] - 10,
        align: 'left',
      });
      const actualHeight = doc.heightOfString(actualText, {
        width: colWidths[2] - 10,
        align: 'left',
      });
      const recommendationsHeight = doc.heightOfString(recommendationsText, {
        width: colWidths[5] - 10,
        align: 'left',
      });

      // For first row, ensure it's tall enough for the areaName text
      const rowHeight = isFirstRow
        ? Math.max(
            rowMinHeight,
            areaNameHeight + 6,
            plannedHeight,
            actualHeight,
            recommendationsHeight,
          ) + 6
        : Math.max(
            rowMinHeight,
            plannedHeight,
            actualHeight,
            recommendationsHeight,
          ) + 6;
      rowHeights.push(rowHeight);
    }

    // Don't do page break check for entire area - handle it per row instead
    let currentAreaSegmentStartY = y; // Track start of current page's segment
    let hasDrawnAreaNameOnCurrentPage = false; // Track if we've drawn areaName on current page

    // Draw each commitment row
    let isFirstRowOnPage = true; // Track if this is the first row on current page
    for (let i = 0; i < commitments.length; i++) {
      const commitment = commitments[i];
      const rowHeight = rowHeights[i];

      const plannedText = commitment.plannedMeasure || '';
      const actualText = commitment.actualObservation || '';
      const recommendationsText = commitment.recommendations || '';

      // Page break check for each row
      if (y + rowHeight > bottomLimit) {
        // Close the merged areaName cell on current page
        doc.strokeColor('#000000').lineWidth(0.5);
        doc.moveTo(left, currentAreaSegmentStartY).lineTo(left, y).stroke();
        doc
          .moveTo(getColX(1), currentAreaSegmentStartY)
          .lineTo(getColX(1), y)
          .stroke();
        // Draw bottom border
        doc
          .moveTo(left, y)
          .lineTo(left + tableWidth, y)
          .stroke();

        doc.addPage();
        y = doc.page.margins.top || 50;
        // Don't redraw header - continue table on new page
        doc.font('Helvetica').fontSize(11);

        isFirstRowOnPage = true; // Reset flag for new page
        currentAreaSegmentStartY = y; // Reset segment start for new page
        hasDrawnAreaNameOnCurrentPage = false; // Need to redraw areaName on new page
      }

      // Draw areaName cell borders and text for current page segment (only once per page)
      if (!hasDrawnAreaNameOnCurrentPage) {
        // Calculate remaining rows on this page
        let remainingHeightOnPage = 0;
        for (let j = i; j < commitments.length; j++) {
          if (y + remainingHeightOnPage + rowHeights[j] > bottomLimit) {
            break; // Stop if next row won't fit
          }
          remainingHeightOnPage += rowHeights[j];
        }

        // Draw merged areaName cell borders for this page segment
        doc.strokeColor('#000000').lineWidth(0.5);
        doc
          .moveTo(left, currentAreaSegmentStartY)
          .lineTo(left, currentAreaSegmentStartY + remainingHeightOnPage)
          .stroke();
        doc
          .moveTo(getColX(1), currentAreaSegmentStartY)
          .lineTo(getColX(1), currentAreaSegmentStartY + remainingHeightOnPage)
          .stroke();

        // Draw areaName text at the top
        const topPadding = useExtraPadding ? 20 : 3;
        doc.font('Helvetica-Bold').fontSize(11);
        doc.text(areaName, left + 5, currentAreaSegmentStartY + topPadding, {
          width: colWidths[0] - 10,
          align: 'center',
        });
        doc.font('Helvetica').fontSize(11); // Reset to normal font

        hasDrawnAreaNameOnCurrentPage = true;
      }

      // Calculate text heights for vertical centering
      const plannedHeight = doc.heightOfString(plannedText, {
        width: colWidths[1] - 10,
        align: 'left',
      });
      const actualHeight = doc.heightOfString(actualText, {
        width: colWidths[2] - 10,
        align: 'left',
      });
      const recommendationsHeight = doc.heightOfString(recommendationsText, {
        width: colWidths[5] - 10,
        align: 'left',
      });

      // Draw top border (only for first row on each page)
      if (isFirstRowOnPage) {
        doc
          .moveTo(left, y)
          .lineTo(left + tableWidth, y)
          .stroke();
        isFirstRowOnPage = false; // Clear flag after drawing
      }

      // Draw vertical borders for columns 2-6 (Planned through Recommendations)
      for (let colIdx = 2; colIdx <= 5; colIdx++) {
        doc
          .moveTo(getColX(colIdx), y)
          .lineTo(getColX(colIdx), y + rowHeight)
          .stroke();
      } // Draw right edge
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      // Draw bottom border for this row (only from column 1 onwards, not across the merged areaName cell)
      doc
        .moveTo(getColX(1), y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      // Draw cell content
      if (plannedText) {
        const textY = y + (rowHeight - plannedHeight) / 2;
        // Add numbering only if text doesn't already start with a number
        const hasNumbering = /^\d+\./.test(plannedText);
        const displayText = hasNumbering
          ? plannedText
          : `${i + 1}. ${plannedText}`;
        doc.text(displayText, getColX(1) + 5, textY, {
          width: colWidths[1] - 10,
          align: 'left',
        });
      }

      if (actualText) {
        const textY = y + (rowHeight - actualHeight) / 2;
        doc.text(actualText, getColX(2) + 5, textY, {
          width: colWidths[2] - 10,
          align: 'left',
        });
      }

      // Draw checkmark for Effective?
      if (commitment.isEffective === true) {
        const checkmarkSize = 4;
        const centerX = getColX(3) + colWidths[3] / 2;
        const centerY = y + rowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      } else if (commitment.isEffective === false) {
        const checkmarkSize = 4;
        const centerX = getColX(4) + colWidths[4] / 2;
        const centerY = y + rowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      if (recommendationsText) {
        const textY = y + (rowHeight - recommendationsHeight) / 2;
        doc.text(recommendationsText, getColX(5) + 5, textY, {
          width: colWidths[5] - 10,
          align: 'left',
        });
      }

      y += rowHeight;
    }
  };

  // Helper function to draw a section header row (merged cells, centered text, regular font)
  const drawSectionHeader = (headerText: string) => {
    doc.font('Helvetica').fontSize(11);

    // Calculate row height
    const textHeight = doc.heightOfString(headerText, {
      width: tableWidth - 10,
      align: 'center',
    });
    const rowHeight = Math.max(rowMinHeight, textHeight) + 6;

    // Page break if needed
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica').fontSize(11);
    }

    // Draw borders
    doc.strokeColor('#000000').lineWidth(0.5);

    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();

    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Bottom border
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Draw centered text (merged across all columns)
    const textY = y + (rowHeight - textHeight) / 2;
    doc.text(headerText, left + 5, textY, {
      width: tableWidth - 10,
      align: 'center',
    });

    y += rowHeight;
  };

  // Process constructionInfo
  if (data.constructionInfo && data.constructionInfo.length > 0) {
    for (const area of data.constructionInfo) {
      const areaName = area.areaName || '';
      const commitments = area.commitments || [];
      processArea(areaName, commitments);
    }
  }

  // Add section header before implementationOfEnvironmentalImpactControlStrategies
  if (
    data.implementationOfEnvironmentalImpactControlStrategies &&
    data.implementationOfEnvironmentalImpactControlStrategies.length > 0
  ) {
    drawSectionHeader(
      'Implementation of Environmental Impact Control Strategies',
    );
  }

  // Process implementationOfEnvironmentalImpactControlStrategies
  if (
    data.implementationOfEnvironmentalImpactControlStrategies &&
    data.implementationOfEnvironmentalImpactControlStrategies.length > 0
  ) {
    for (const area of data.implementationOfEnvironmentalImpactControlStrategies) {
      const areaName = area.areaName || '';
      const commitments = area.commitments || [];
      processArea(areaName, commitments, true); // Use extra padding for implementation sections
    }
  }

  // Display Overall Compliance Assessment as a single merged row
  if (data.overallComplianceAssessment) {
    const labelText = 'Overall Compliance Assessment: ';
    const valueText = data.overallComplianceAssessment;

    // Calculate combined text width for centering
    doc.font('Helvetica').fontSize(11);
    const labelWidth = doc.widthOfString(labelText);
    doc.font('Helvetica-Bold').fontSize(11);
    const valueWidth = doc.widthOfString(valueText);
    const totalTextWidth = labelWidth + valueWidth;

    // Calculate row height
    doc.font('Helvetica').fontSize(11);
    const textHeight = doc.heightOfString(labelText, {
      width: tableWidth - 10,
      align: 'left',
    });
    const rowHeight = Math.max(rowMinHeight, textHeight) + 6;

    // Page break if needed
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
    }

    // Draw borders
    doc.strokeColor('#000000').lineWidth(0.5);

    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();

    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Bottom border
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Calculate starting X position to center the combined text
    const startX = left + (tableWidth - totalTextWidth) / 2;
    const textY = y + (rowHeight - textHeight) / 2;

    // Draw label text (regular font)
    doc.font('Helvetica').fontSize(11);
    doc.text(labelText, startX, textY, {
      continued: true,
      lineBreak: false,
    });

    // Draw value text (bold font)
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text(valueText, {
      lineBreak: false,
    });

    y += rowHeight;
  }

  doc.y = y;
  doc.moveDown(0.5);
}

/**
 * Draw the Air Quality Impact Assessment table with 9 columns including nested headers
 */
export function drawAirQualityImpactAssessmentTable(
  doc: PDFKit.PDFDocument,
  data: {
    quarry?: string;
    quarryPlant?: string;
    plant?: string;
    port?: string;
    parameters?: Array<{
      name?: string;
      results?: {
        inSMR?: {
          current?: string;
          previous?: string;
        };
        mmtConfirmatorySampling?: {
          current?: string;
          previous?: string;
        };
      };
      eqpl?: {
        redFlag?: string;
        action?: string;
        limit?: string;
      };
      remarks?: string;
    }>;
    samplingDate?: string;
    weatherAndWind?: string;
    explanationForConfirmatorySampling?: string;
    overallAssessment?: string;
  },
) {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const bottomMargin = doc.page.margins.bottom || 50;
  const bottomLimit = doc.page.height - bottomMargin - 30;

  let y = doc.y;

  // Display quarry, plant, and port as text paragraphs with indentation
  const textIndent = 60; // Indent from left margin

  if (data.quarry) {
    // Bold label, regular text for value
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text('Quarry: ', left + textIndent, y, {
      continued: true,
      lineBreak: false,
    });
    doc.font('Helvetica').fontSize(11);
    doc.text(data.quarry);
    y = doc.y;
    doc.moveDown(0.3);
    y = doc.y;
  }

  if (data.quarryPlant) {
    // Bold label, regular text for value
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text('Quarry/Plant: ', left + textIndent, y, {
      continued: true,
      lineBreak: false,
    });
    doc.font('Helvetica').fontSize(11);
    doc.text(data.quarryPlant);
    y = doc.y;
    doc.moveDown(0.3);
    y = doc.y;
  }

  if (data.plant) {
    // Bold label, regular text for value
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text('Plant: ', left + textIndent, y, {
      continued: true,
      lineBreak: false,
    });
    doc.font('Helvetica').fontSize(11);
    doc.text(data.plant);
    y = doc.y;
    doc.moveDown(0.3);
    y = doc.y;
  }

  if (data.port) {
    // Bold label, regular text for value
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text('Port: ', left + textIndent, y, {
      continued: true,
      lineBreak: false,
    });
    doc.font('Helvetica').fontSize(11);
    doc.text(data.port);
    y = doc.y;
    doc.moveDown(1.5);
    y = doc.y;
  }

  // Check if we need to add a page before the table
  if (y + 100 > bottomLimit) {
    doc.addPage();
    y = doc.page.margins.top || 50;
  }

  // Define column structure: 9 columns total
  // Parameter | Results (4 cols) | EQPL (3 cols) | Remarks
  // Results: inSMR (Current, Previous), mmtConfirmatorySampling (Current, Previous)
  // EQPL: Red Flag, Action, Limit
  const colWidths = [
    tableWidth * 0.12, // Parameter
    tableWidth * 0.11, // inSMR Current
    tableWidth * 0.11, // inSMR Previous
    tableWidth * 0.11, // MMT Current
    tableWidth * 0.11, // MMT Previous
    tableWidth * 0.11, // Red Flag
    tableWidth * 0.11, // Action
    tableWidth * 0.11, // Limit
    tableWidth * 0.11, // Remarks
  ];

  const getColX = (colIndex: number): number =>
    left + colWidths.slice(0, colIndex).reduce((s, w) => s + w, 0);

  // Draw three-row header
  const header1Height = 20; // "Results" and "EQPL" row
  const header2Height = 40; // "inSMR" and "mmtConfirmatorySampling" row
  const header3Height = 20; // Individual column names row
  const totalHeaderHeight = header1Height + header2Height + header3Height;

  const drawHeader = (startY: number): number => {
    let currentY = startY;
    doc.font('Helvetica-Bold').fontSize(10);
    doc.strokeColor('#000000').lineWidth(0.5);

    // Row 1: Parameter (merged 3 rows) | Results (4 cols merged) | EQPL (3 cols merged) | Remarks (merged 3 rows)
    // Top border
    doc
      .moveTo(left, currentY)
      .lineTo(left + tableWidth, currentY)
      .stroke();

    // Draw Parameter cell (spans all 3 rows)
    const paramX = getColX(0);
    const paramWidth = colWidths[0];
    doc
      .moveTo(paramX, currentY)
      .lineTo(paramX, currentY + totalHeaderHeight)
      .stroke();
    doc
      .moveTo(paramX + paramWidth, currentY)
      .lineTo(paramX + paramWidth, currentY + totalHeaderHeight)
      .stroke();
    const paramTextHeight = doc.heightOfString('Parameter', {
      width: paramWidth - 4,
      align: 'center',
    });
    doc.text(
      'Parameter',
      paramX + 2,
      currentY + (totalHeaderHeight - paramTextHeight) / 2,
      {
        width: paramWidth - 4,
        align: 'center',
      },
    );

    // Draw Results cell (row 1 only)
    const resultsX = getColX(1);
    const resultsWidth =
      colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4];
    doc
      .moveTo(resultsX, currentY)
      .lineTo(resultsX, currentY + header1Height)
      .stroke();
    doc
      .moveTo(resultsX + resultsWidth, currentY)
      .lineTo(resultsX + resultsWidth, currentY + header1Height)
      .stroke();
    const resultsTextHeight = doc.heightOfString('Results', {
      width: resultsWidth - 4,
      align: 'center',
    });
    doc.text(
      'Results',
      resultsX + 2,
      currentY + (header1Height - resultsTextHeight) / 2,
      {
        width: resultsWidth - 4,
        align: 'center',
      },
    );

    // Draw EQPL cell (spans rows 1, 2, and 3) with sub-columns
    const eqplX = getColX(5);
    const eqplWidth = colWidths[5] + colWidths[6] + colWidths[7];
    doc
      .moveTo(eqplX, currentY)
      .lineTo(eqplX, currentY + totalHeaderHeight)
      .stroke();
    doc
      .moveTo(eqplX + eqplWidth, currentY)
      .lineTo(eqplX + eqplWidth, currentY + totalHeaderHeight)
      .stroke();

    // Draw EQPL title at the top (bold)
    doc.font('Helvetica-Bold').fontSize(10);
    const eqplTitleHeight = doc.heightOfString('EQPL', {
      width: eqplWidth - 4,
      align: 'center',
    });
    doc.text('EQPL', eqplX + 2, currentY + 4, {
      width: eqplWidth - 4,
      align: 'center',
    });

    // Draw horizontal line below EQPL title to separate from sub-columns
    const eqplTitleBottomY = currentY + eqplTitleHeight + 8;
    doc
      .moveTo(eqplX, eqplTitleBottomY)
      .lineTo(eqplX + eqplWidth, eqplTitleBottomY)
      .stroke();

    // Draw internal vertical borders for EQPL sub-columns (only below the title line)
    for (let i = 6; i <= 7; i++) {
      const colX = getColX(i);
      doc
        .moveTo(colX, eqplTitleBottomY)
        .lineTo(colX, currentY + totalHeaderHeight)
        .stroke();
    }

    // Draw sub-column labels (Red Flag, Action, Limit) below EQPL title
    const eqplSubLabels = ['Red Flag', 'Action', 'Limit\n(DENR std.\nPM 2.5)'];
    const eqplSubAreaHeight = currentY + totalHeaderHeight - eqplTitleBottomY;

    for (let i = 0; i < 3; i++) {
      const colIndex = 5 + i;
      const colX = getColX(colIndex);
      const colWidth = colWidths[colIndex];

      doc.font('Helvetica-Bold').fontSize(11);

      // Calculate text height for vertical centering
      const textHeight = doc.heightOfString(eqplSubLabels[i], {
        width: colWidth - 4,
        align: 'center',
      });

      // Center vertically within the sub-area
      const centeredY = eqplTitleBottomY + (eqplSubAreaHeight - textHeight) / 2;

      doc.text(eqplSubLabels[i], colX + 2, centeredY, {
        width: colWidth - 4,
        align: 'center',
      });
    }

    doc.font('Helvetica-Bold').fontSize(10); // Reset to bold for other headers

    // Draw Remarks cell (spans all 3 rows)
    const remarksX = getColX(8);
    const remarksWidth = colWidths[8];
    doc
      .moveTo(remarksX, currentY)
      .lineTo(remarksX, currentY + totalHeaderHeight)
      .stroke();
    doc
      .moveTo(remarksX + remarksWidth, currentY)
      .lineTo(remarksX + remarksWidth, currentY + totalHeaderHeight)
      .stroke();
    const remarksTextHeight = doc.heightOfString('Remarks', {
      width: remarksWidth - 4,
      align: 'center',
    });
    doc.text(
      'Remarks',
      remarksX + 2,
      currentY + (totalHeaderHeight - remarksTextHeight) / 2,
      {
        width: remarksWidth - 4,
        align: 'center',
      },
    );

    // Bottom border of row 1
    doc
      .moveTo(resultsX, currentY + header1Height)
      .lineTo(resultsX + resultsWidth, currentY + header1Height)
      .stroke();

    currentY += header1Height;

    // Row 2: inSMR (2 cols merged) | mmtConfirmatorySampling (2 cols merged)
    const row2Cells = [
      {
        text: 'In SMR c/o Geosphere Technologies, Inc.',
        x: getColX(1),
        width: colWidths[1] + colWidths[2],
        colSpan: 2,
      },
      {
        text: 'MMT Confirmatory Sampling',
        x: getColX(3),
        width: colWidths[3] + colWidths[4],
        colSpan: 2,
      },
    ];

    row2Cells.forEach((cell) => {
      // Left border
      doc
        .moveTo(cell.x, currentY)
        .lineTo(cell.x, currentY + header2Height)
        .stroke();
      // Right border
      doc
        .moveTo(cell.x + cell.width, currentY)
        .lineTo(cell.x + cell.width, currentY + header2Height)
        .stroke();
      // Text
      const textHeight = doc.heightOfString(cell.text, {
        width: cell.width - 4,
        align: 'center',
      });
      doc.text(
        cell.text,
        cell.x + 2,
        currentY + (header2Height - textHeight) / 2,
        {
          width: cell.width - 4,
          align: 'center',
        },
      );
    });

    // Bottom border of row 2
    doc
      .moveTo(resultsX, currentY + header2Height)
      .lineTo(resultsX + resultsWidth, currentY + header2Height)
      .stroke();

    currentY += header2Height;

    // Row 3: Current | Previous | Current | Previous (only for Results columns)
    const row3Headers = ['Current', 'Previous', 'Current', 'Previous'];

    for (let i = 0; i < row3Headers.length; i++) {
      const colIndex = i + 1; // Start from column 1 (after Parameter)
      const colX = getColX(colIndex);
      const colWidth = colWidths[colIndex];

      // Left border
      doc
        .moveTo(colX, currentY)
        .lineTo(colX, currentY + header3Height)
        .stroke();
      // Right border
      doc
        .moveTo(colX + colWidth, currentY)
        .lineTo(colX + colWidth, currentY + header3Height)
        .stroke();

      // Text
      const textHeight = doc.heightOfString(row3Headers[i], {
        width: colWidth - 4,
        align: 'center',
      });
      doc.text(
        row3Headers[i],
        colX + 2,
        currentY + (header3Height - textHeight) / 2,
        {
          width: colWidth - 4,
          align: 'center',
        },
      );
    }

    // Bottom border of row 3 (full width)
    doc
      .moveTo(left, currentY + header3Height)
      .lineTo(left + tableWidth, currentY + header3Height)
      .stroke();

    currentY += header3Height;

    return currentY;
  };

  // Draw initial header
  y = drawHeader(y);

  // Draw parameter rows
  doc.font('Helvetica').fontSize(10);

  if (data.parameters && data.parameters.length > 0) {
    for (const param of data.parameters) {
      const rowData = [
        param.name || '',
        param.results?.inSMR?.current || '',
        param.results?.inSMR?.previous || '',
        param.results?.mmtConfirmatorySampling?.current || '',
        param.results?.mmtConfirmatorySampling?.previous || '',
        param.eqpl?.redFlag || '',
        param.eqpl?.action || '',
        param.eqpl?.limit || '',
        param.remarks || '',
      ];

      // Calculate row height based on content
      const cellHeights = rowData.map((text, idx) =>
        doc.heightOfString(text, {
          width: colWidths[idx] - 4,
          align: 'center',
        }),
      );
      const rowHeight = Math.max(14, ...cellHeights) + 4;

      // Check if we need a page break
      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        y = drawHeader(y);
      }

      // Draw row
      for (let i = 0; i < rowData.length; i++) {
        const colX = getColX(i);
        const colWidth = colWidths[i];

        // Left border
        doc
          .moveTo(colX, y)
          .lineTo(colX, y + rowHeight)
          .stroke();
        // Right border
        doc
          .moveTo(colX + colWidth, y)
          .lineTo(colX + colWidth, y + rowHeight)
          .stroke();

        // Text - bold for parameter name (column 0), regular for others
        if (i === 0) {
          doc.font('Helvetica-Bold').fontSize(10);
        } else {
          doc.font('Helvetica').fontSize(10);
        }

        const textHeight = doc.heightOfString(rowData[i], {
          width: colWidth - 4,
          align: 'center',
        });
        doc.text(rowData[i], colX + 2, y + (rowHeight - textHeight) / 2, {
          width: colWidth - 4,
          align: 'center',
        });
      }

      // Reset font
      doc.font('Helvetica').fontSize(10);

      // Bottom border
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      y += rowHeight;
    }
  }

  // Draw the 4 additional rows (full width, centered text)
  const additionalRows = [
    { label: 'Date/ time of sampling:', value: data.samplingDate || '' },
    { label: 'Weather and wind direction:', value: data.weatherAndWind || '' },
    {
      label:
        'Explanation of why confirmatory sampling was conducted for specific parameter in the sampling station:',
      value: data.explanationForConfirmatorySampling || '',
    },
    { label: 'Overall Assessment:', value: data.overallAssessment || '' },
  ];

  doc.font('Helvetica').fontSize(10);

  for (const row of additionalRows) {
    const isOverallAssessment = row.label === 'Overall Assessment:';

    // For Overall Assessment, we need to handle bold value separately
    if (isOverallAssessment) {
      // Calculate combined width for positioning
      const labelWidth = doc.widthOfString(row.label);
      const valueWidth = doc.font('Helvetica-Bold').widthOfString(row.value);
      const totalWidth = labelWidth + doc.widthOfString(' ') + valueWidth;

      const textHeight = Math.max(
        doc.font('Helvetica').heightOfString(row.label, {
          width: tableWidth - 10,
        }),
        doc.font('Helvetica-Bold').heightOfString(row.value, {
          width: tableWidth - 10,
        }),
      );
      const rowHeight = Math.max(14, textHeight) + 4;

      // Check if we need a page break
      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
      }

      // Draw borders
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + rowHeight)
        .stroke();
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      // Calculate starting X to center the text
      const startX = left + (tableWidth - totalWidth) / 2;
      const textY = y + (rowHeight - textHeight) / 2;

      // Draw label (regular)
      doc.font('Helvetica').fontSize(10);
      doc.text(row.label, startX, textY, {
        continued: true,
        lineBreak: false,
      });

      // Draw space
      doc.text(' ', {
        continued: true,
        lineBreak: false,
      });

      // Draw value (bold)
      doc.font('Helvetica-Bold').fontSize(10);
      doc.text(row.value, {
        lineBreak: false,
      });

      y += rowHeight;
    } else {
      // Regular rows with normal text
      const combinedText = `${row.label} ${row.value}`;
      const textHeight = doc.heightOfString(combinedText, {
        width: tableWidth - 10,
        align: 'left',
      });
      const rowHeight = Math.max(14, textHeight) + 4;

      // Check if we need a page break
      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
      }

      // Draw borders
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + rowHeight)
        .stroke();
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      // Text (centered)
      doc.font('Helvetica').fontSize(10);
      doc.text(combinedText, left + 5, y + (rowHeight - textHeight) / 2, {
        width: tableWidth - 10,
        align: 'left',
      });

      y += rowHeight;
    }
  }

  doc.y = y;
  doc.moveDown(0.5);
}

/**
 * Draw the Water Quality Impact Assessment table
 */
export function drawWaterQualityImpactAssessmentTable(
  doc: PDFKit.PDFDocument,
  data: {
    quarry?: string;
    quarryPlant?: string;
    plant?: string;
    port?: string;
    parameters?: Array<{
      name?: string;
      result?: {
        internalMonitoring?: {
          month?: string;
          readings?: Array<{
            label?: string;
            current_mgL?: number;
            previous_mgL?: number;
          }>;
        };
        mmtConfirmatorySampling?: {
          current?: string;
          previous?: string;
        };
      };
      denrStandard?: {
        redFlag?: string;
        action?: string;
        limit_mgL?: number;
      };
      remark?: string;
    }>;
    parametersTable2?: Array<{
      name?: string;
      result?: {
        internalMonitoring?: {
          month?: string;
          readings?: Array<{
            label?: string;
            current_mgL?: number;
            previous_mgL?: number;
          }>;
        };
        mmtConfirmatorySampling?: {
          current?: string;
          previous?: string;
        };
      };
      denrStandard?: {
        redFlag?: string;
        action?: string;
        limit_mgL?: number;
      };
      remark?: string;
    }>;
    samplingDate?: string;
    weatherAndWind?: string;
    explanationForConfirmatorySampling?: string;
    overallAssessment?: string;
  },
) {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  let y = doc.y;

  // Helper function to render text fields
  const renderTextField = (label: string, value: string) => {
    const textIndent = 60;
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text(`${label}: `, left + textIndent, y, {
      continued: true,
      lineBreak: false,
    });
    doc.font('Helvetica').fontSize(11);
    doc.text(value);
    y = doc.y;
  };

  // Quarry text
  if (data.quarry) {
    renderTextField('Quarry', data.quarry);
  }

  // Quarry Plant text
  if (data.quarryPlant) {
    renderTextField('Quarry Plant', data.quarryPlant);
  }

  // Plant text
  if (data.plant) {
    renderTextField('Plant', data.plant);
  }

  doc.moveDown(2);
  y = doc.y;

  // Column structure: Parameter | Month | Current (mg/L) | Previous (mg/L) | MMT Current | MMT Previous | Red Flag | Action | Limit | Remark
  const parameterWidth = tableWidth * 0.12;
  const monthWidth = tableWidth * 0.08;
  const currentWidth = tableWidth * 0.14;
  const previousWidth = tableWidth * 0.14;
  const mmtCurrentWidth = tableWidth * 0.09;
  const mmtPreviousWidth = tableWidth * 0.09;
  const redFlagWidth = tableWidth * 0.08;
  const actionWidth = tableWidth * 0.08;
  const limitWidth = tableWidth * 0.08;
  const remarksWidth = tableWidth * 0.1;

  // Calculate X positions
  const parameterX = left;
  const monthX = parameterX + parameterWidth;
  const currentX = monthX + monthWidth;
  const previousX = currentX + currentWidth;
  const mmtCurrentX = previousX + previousWidth;
  const mmtPreviousX = mmtCurrentX + mmtCurrentWidth;
  const redFlagX = mmtPreviousX + mmtPreviousWidth;
  const actionX = redFlagX + redFlagWidth;
  const limitX = actionX + actionWidth;
  const remarksX = limitX + limitWidth;

  // Draw the header (3 rows)
  const headerRow1Height = 18;
  const headerRow2Height = 43;
  const headerRow3Height = 30;
  const totalHeaderHeight =
    headerRow1Height + headerRow2Height + headerRow3Height;

  const currentY = y;

  // Row 1: Parameter | Result | DENR Standard | Remark
  doc.font('Helvetica-Bold').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Outer borders for row 1
  doc
    .moveTo(left, currentY)
    .lineTo(left + tableWidth, currentY)
    .stroke(); // Top

  // Left edge of table
  doc
    .moveTo(parameterX, currentY)
    .lineTo(parameterX, currentY + totalHeaderHeight)
    .stroke();

  // Parameter column border (right edge) - merged 3 rows, no internal lines
  doc
    .moveTo(monthX, currentY)
    .lineTo(monthX, currentY + totalHeaderHeight)
    .stroke();

  // Parameter text (centered vertically in merged cell)
  const parameterText = 'Parameter';
  const parameterTextHeight = doc.heightOfString(parameterText, {
    width: parameterWidth - 5,
    align: 'center',
  });
  const parameterCenteredY =
    currentY + (totalHeaderHeight - parameterTextHeight) / 2;
  doc.text(parameterText, parameterX + 2, parameterCenteredY, {
    width: parameterWidth - 4,
    align: 'center',
  });

  // Result header (spans Month + Current + Previous + MMT Current + MMT Previous)
  const resultWidth =
    monthWidth +
    currentWidth +
    previousWidth +
    mmtCurrentWidth +
    mmtPreviousWidth;
  const resultX = monthX;
  doc
    .moveTo(resultX + resultWidth, currentY)
    .lineTo(resultX + resultWidth, currentY + headerRow1Height)
    .stroke();
  doc.text('Result', resultX + 2, currentY + 4, {
    width: resultWidth - 4,
    align: 'center',
  });

  // DENR Standard header (spans Red Flag + Action + Limit) - merged with row 2, no line below
  const denrWidth = redFlagWidth + actionWidth + limitWidth;
  const denrX = redFlagX;
  const denrMergedHeight = headerRow1Height + headerRow2Height;
  doc
    .moveTo(denrX, currentY)
    .lineTo(denrX, currentY + denrMergedHeight)
    .stroke();
  doc
    .moveTo(denrX + denrWidth, currentY)
    .lineTo(denrX + denrWidth, currentY + denrMergedHeight)
    .stroke();

  // DENR Standard text (centered vertically in merged cell across rows 1 and 2)
  const denrText = 'DENR Standard';
  const denrTextHeight = doc.heightOfString(denrText, {
    width: denrWidth - 4,
    align: 'center',
  });
  const denrCenteredY = currentY + (denrMergedHeight - denrTextHeight) / 2;
  doc.text(denrText, denrX + 2, denrCenteredY, {
    width: denrWidth - 4,
    align: 'center',
  });

  // Remark column border (left edge) - merged 3 rows, no internal lines
  doc
    .moveTo(remarksX, currentY)
    .lineTo(remarksX, currentY + totalHeaderHeight)
    .stroke();

  // Right edge of table
  doc
    .moveTo(remarksX + remarksWidth, currentY)
    .lineTo(remarksX + remarksWidth, currentY + totalHeaderHeight)
    .stroke();

  // Remark text (centered vertically in merged cell)
  const remarksText = 'Remark';
  const remarksTextHeight = doc.heightOfString(remarksText, {
    width: remarksWidth - 5,
    align: 'center',
  });
  const remarksCenteredY =
    currentY + (totalHeaderHeight - remarksTextHeight) / 2;
  doc.text(remarksText, remarksX + 2, remarksCenteredY, {
    width: remarksWidth - 4,
    align: 'center',
  });

  // Bottom of row 1 (only between monthX and denrX, not under Parameter, DENR Standard, or Remark)
  doc
    .moveTo(monthX, currentY + headerRow1Height)
    .lineTo(denrX, currentY + headerRow1Height)
    .stroke();

  // Row 2: Internal Monitoring | MMT Confirmatory Sampling
  const row2Y = currentY + headerRow1Height;

  // Internal Monitoring (spans Month + Current + Previous)
  const internalMonitoringWidth = monthWidth + currentWidth + previousWidth;
  const internalMonitoringX = monthX;
  doc
    .moveTo(internalMonitoringX, row2Y)
    .lineTo(internalMonitoringX, row2Y + headerRow2Height)
    .stroke();
  doc
    .moveTo(internalMonitoringX + internalMonitoringWidth, row2Y)
    .lineTo(
      internalMonitoringX + internalMonitoringWidth,
      row2Y + headerRow2Height,
    )
    .stroke();
  doc.text('Internal Monitoring', internalMonitoringX + 2, row2Y + 4, {
    width: internalMonitoringWidth - 4,
    align: 'center',
  });

  // MMT Confirmatory Sampling (spans MMT Current + MMT Previous)
  const mmtWidth = mmtCurrentWidth + mmtPreviousWidth;
  const mmtX = mmtCurrentX;
  doc
    .moveTo(mmtX, row2Y)
    .lineTo(mmtX, row2Y + headerRow2Height)
    .stroke();
  doc
    .moveTo(mmtX + mmtWidth, row2Y)
    .lineTo(mmtX + mmtWidth, row2Y + headerRow2Height)
    .stroke();
  doc.text('MMT Confirmatory Sampling', mmtX + 2, row2Y + 4, {
    width: mmtWidth - 4,
    align: 'center',
  });

  // Bottom of row 2 (only between monthX and denrX, not under Parameter or Remark)
  // Also need to draw bottom line for DENR Standard section (where it will split into Red Flag, Action, Limit)
  doc
    .moveTo(monthX, row2Y + headerRow2Height)
    .lineTo(denrX, row2Y + headerRow2Height)
    .stroke();

  // Bottom line of DENR Standard (between denrX and remarksX)
  doc
    .moveTo(denrX, row2Y + headerRow2Height)
    .lineTo(remarksX, row2Y + headerRow2Height)
    .stroke();

  // Row 3: Month | Current (mg/L) | Previous (mg/L) | Current | Previous | Red Flag | Action | Limit mg/L
  const row3Y = row2Y + headerRow2Height;

  // Month
  doc
    .moveTo(monthX, row3Y)
    .lineTo(monthX, row3Y + headerRow3Height)
    .stroke();
  doc
    .moveTo(currentX, row3Y)
    .lineTo(currentX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Month', monthX + 2, row3Y + 5, {
    width: monthWidth - 4,
    align: 'center',
  });

  // Current (mg/L)
  doc
    .moveTo(previousX, row3Y)
    .lineTo(previousX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Current', currentX + 2, row3Y + 3, {
    width: currentWidth - 4,
    align: 'center',
    lineBreak: false,
  });
  doc.text('(mg/L)', currentX + 2, row3Y + 12, {
    width: currentWidth - 4,
    align: 'center',
  });
  doc.font('Helvetica-Bold').fontSize(11);

  // Previous (mg/L)
  doc
    .moveTo(mmtCurrentX, row3Y)
    .lineTo(mmtCurrentX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Previous', previousX + 2, row3Y + 3, {
    width: previousWidth - 4,
    align: 'center',
    lineBreak: false,
  });
  doc.text('(mg/L)', previousX + 2, row3Y + 12, {
    width: previousWidth - 4,
    align: 'center',
  });
  doc.font('Helvetica-Bold').fontSize(9);

  // MMT Current
  doc
    .moveTo(mmtPreviousX, row3Y)
    .lineTo(mmtPreviousX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Current', mmtCurrentX + 2, row3Y + 7, {
    width: mmtCurrentWidth - 4,
    align: 'center',
  });

  // MMT Previous
  doc
    .moveTo(redFlagX, row3Y)
    .lineTo(redFlagX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Previous', mmtPreviousX + 2, row3Y + 7, {
    width: mmtPreviousWidth - 4,
    align: 'center',
  });

  // Red Flag
  doc
    .moveTo(actionX, row3Y)
    .lineTo(actionX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Red Flag', redFlagX + 2, row3Y + 7, {
    width: redFlagWidth - 4,
    align: 'center',
  });

  // Action
  doc
    .moveTo(limitX, row3Y)
    .lineTo(limitX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Action', actionX + 2, row3Y + 7, {
    width: actionWidth - 4,
    align: 'center',
  });

  // Limit mg/L
  doc
    .moveTo(remarksX, row3Y)
    .lineTo(remarksX, row3Y + headerRow3Height)
    .stroke();
  doc.text('Limit', limitX + 2, row3Y + 3, {
    width: limitWidth - 4,
    align: 'center',
    lineBreak: false,
  });
  doc.text('mg/L', limitX + 2, row3Y + 12, {
    width: limitWidth - 4,
    align: 'center',
  });
  doc.font('Helvetica-Bold').fontSize(11);

  // Bottom of row 3 (end of header) - full width this time
  doc
    .moveTo(left, row3Y + headerRow3Height)
    .lineTo(left + tableWidth, row3Y + headerRow3Height)
    .stroke();

  y = currentY + totalHeaderHeight;

  // Data rows
  if (data.parameters && data.parameters.length > 0) {
    for (const param of data.parameters) {
      const paramName = param.name || '';
      const month = param.result?.internalMonitoring?.month || '';
      const readings = param.result?.internalMonitoring?.readings || [];
      const mmtCurrent = param.result?.mmtConfirmatorySampling?.current || '-';
      const mmtPrevious =
        param.result?.mmtConfirmatorySampling?.previous || '-';
      const redFlag = param.denrStandard?.redFlag || '-';
      const action = param.denrStandard?.action || '-';
      const limit = param.denrStandard?.limit_mgL
        ? param.denrStandard.limit_mgL.toString()
        : '-';
      const remark = param.remark || '';

      // Calculate height needed for parameter name with text wrapping
      doc.font('Helvetica-Bold').fontSize(9);
      const paramTextHeight = doc.heightOfString(paramName, {
        width: parameterWidth - 4,
        align: 'center',
      });

      // Calculate height needed for remark with text wrapping
      doc.font('Helvetica').fontSize(8);
      const remarkTextHeight = doc.heightOfString(remark, {
        width: remarksWidth - 4,
        align: 'center',
      });

      // Calculate total height for this parameter (all readings)
      const readingCount = readings.length > 0 ? readings.length : 1;
      const minRowHeight = 27;
      const singleRowHeight = Math.max(
        minRowHeight,
        paramTextHeight + 6,
        remarkTextHeight + 6,
      );
      const totalParamHeight = singleRowHeight * readingCount;

      // Check for page break - if the entire parameter doesn't fit, add a new page
      let needsTopBorder = false;
      if (y + totalParamHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        needsTopBorder = true;
      }

      const startY = y;

      // Draw top border if this is the first row on a new page
      if (needsTopBorder) {
        doc.strokeColor('#000000').lineWidth(0.5);
        doc
          .moveTo(left, y)
          .lineTo(left + tableWidth, y)
          .stroke();
      }

      // For each reading (TSS 01, TSS 02, TSS 03), create a sub-row
      if (readings.length > 0) {
        for (let i = 0; i < readings.length; i++) {
          const reading = readings[i];
          const label = reading.label || '';
          const currentMgL = reading.current_mgL?.toString() || '-';
          const previousMgL = reading.previous_mgL?.toString() || '-';

          doc.font('Helvetica').fontSize(11);

          // Draw vertical borders for this row
          doc.strokeColor('#000000').lineWidth(0.5);

          // Left border (parameter column)
          doc
            .moveTo(parameterX, y)
            .lineTo(parameterX, y + singleRowHeight)
            .stroke();

          // Month column border
          doc
            .moveTo(monthX, y)
            .lineTo(monthX, y + singleRowHeight)
            .stroke();

          // Current column border
          doc
            .moveTo(currentX, y)
            .lineTo(currentX, y + singleRowHeight)
            .stroke();

          // Previous column border
          doc
            .moveTo(previousX, y)
            .lineTo(previousX, y + singleRowHeight)
            .stroke();

          // MMT Current border
          doc
            .moveTo(mmtCurrentX, y)
            .lineTo(mmtCurrentX, y + singleRowHeight)
            .stroke();

          // MMT Previous border
          doc
            .moveTo(mmtPreviousX, y)
            .lineTo(mmtPreviousX, y + singleRowHeight)
            .stroke();

          // Red Flag border
          doc
            .moveTo(redFlagX, y)
            .lineTo(redFlagX, y + singleRowHeight)
            .stroke();

          // Action border
          doc
            .moveTo(actionX, y)
            .lineTo(actionX, y + singleRowHeight)
            .stroke();

          // Limit border
          doc
            .moveTo(limitX, y)
            .lineTo(limitX, y + singleRowHeight)
            .stroke();

          // Remark border
          doc
            .moveTo(remarksX, y)
            .lineTo(remarksX, y + singleRowHeight)
            .stroke();

          // Right border (remark column)
          doc
            .moveTo(remarksX + remarksWidth, y)
            .lineTo(remarksX + remarksWidth, y + singleRowHeight)
            .stroke();

          // Current column: Display label and value separated by a line
          // Draw label on the left half
          const labelWidthRatio = 0.5; // 50% for label, 50% for value
          const currentLabelWidth = currentWidth * labelWidthRatio;
          const currentValueWidth = currentWidth * (1 - labelWidthRatio);
          const currentLabelX = currentX;
          const currentValueX = currentX + currentLabelWidth;

          doc.fontSize(10);

          // Draw vertical separator line in Current column
          doc
            .moveTo(currentValueX, y)
            .lineTo(currentValueX, y + singleRowHeight)
            .stroke();

          // Label (left side)
          doc.text(label, currentLabelX + 2, y + 5, {
            width: currentLabelWidth - 4,
            align: 'center',
          });

          doc.fontSize(11);

          // Value (right side)
          doc.text(currentMgL, currentValueX + 2, y + 5, {
            width: currentValueWidth - 4,
            align: 'center',
          });

          // Previous column: Display label and value separated by a line
          const previousLabelWidth = previousWidth * labelWidthRatio;
          const previousValueWidth = previousWidth * (1 - labelWidthRatio);
          const previousLabelX = previousX;
          const previousValueX = previousX + previousLabelWidth;

          // Draw vertical separator line in Previous column
          doc
            .moveTo(previousValueX, y)
            .lineTo(previousValueX, y + singleRowHeight)
            .stroke();

          doc.fontSize(10);

          // Label (left side)
          doc.text(label, previousLabelX + 2, y + 5, {
            width: previousLabelWidth - 4,
            align: 'center',
          });

          doc.fontSize(11);

          // Value (right side)
          doc.text(previousMgL, previousValueX + 2, y + 5, {
            width: previousValueWidth - 4,
            align: 'center',
          });

          doc.fontSize(11);

          // Draw horizontal border between readings (but not after last one)
          if (i < readings.length - 1) {
            // Draw internal horizontal line only for Current and Previous columns
            doc
              .moveTo(currentX, y + singleRowHeight)
              .lineTo(previousX + previousWidth, y + singleRowHeight)
              .stroke();
          }

          y += singleRowHeight;
        }

        // Draw the merged cells content after all rows
        // Parameter name (bold, centered vertically)
        doc.font('Helvetica-Bold').fontSize(9);
        const paramTextHeight2 = doc.heightOfString(paramName, {
          width: parameterWidth - 4,
          align: 'center',
        });
        const paramCenterY = startY + (totalParamHeight - paramTextHeight2) / 2;
        doc.text(paramName, parameterX + 2, paramCenterY, {
          width: parameterWidth - 4,
          align: 'center',
        });

        // Month (centered vertically)
        doc.font('Helvetica').fontSize(11);
        const monthTextHeight = doc.heightOfString(month, {
          width: monthWidth - 4,
          align: 'center',
        });
        const monthCenterY = startY + (totalParamHeight - monthTextHeight) / 2;
        doc.text(month, monthX + 2, monthCenterY, {
          width: monthWidth - 4,
          align: 'center',
        });

        // MMT Current (centered vertically)
        const mmtCurrentTextHeight = doc.heightOfString(mmtCurrent, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });
        const mmtCurrentCenterY =
          startY + (totalParamHeight - mmtCurrentTextHeight) / 2;
        doc.text(mmtCurrent, mmtCurrentX + 2, mmtCurrentCenterY, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });

        // MMT Previous (centered vertically)
        const mmtPreviousTextHeight = doc.heightOfString(mmtPrevious, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });
        const mmtPreviousCenterY =
          startY + (totalParamHeight - mmtPreviousTextHeight) / 2;
        doc.text(mmtPrevious, mmtPreviousX + 2, mmtPreviousCenterY, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });

        // DENR Red Flag (centered vertically)
        const redFlagTextHeight = doc.heightOfString(redFlag, {
          width: redFlagWidth - 4,
          align: 'center',
        });
        const redFlagCenterY =
          startY + (totalParamHeight - redFlagTextHeight) / 2;
        doc.text(redFlag, redFlagX + 2, redFlagCenterY, {
          width: redFlagWidth - 4,
          align: 'center',
        });

        // DENR Action (centered vertically)
        const actionTextHeight = doc.heightOfString(action, {
          width: actionWidth - 4,
          align: 'center',
        });
        const actionCenterY =
          startY + (totalParamHeight - actionTextHeight) / 2;
        doc.text(action, actionX + 2, actionCenterY, {
          width: actionWidth - 4,
          align: 'center',
        });

        // DENR Limit (centered vertically)
        const limitTextHeight = doc.heightOfString(limit, {
          width: limitWidth - 4,
          align: 'center',
        });
        const limitCenterY = startY + (totalParamHeight - limitTextHeight) / 2;
        doc.text(limit, limitX + 2, limitCenterY, {
          width: limitWidth - 4,
          align: 'center',
        });

        // Remark (centered vertically)
        const remarkTextHeight = doc.heightOfString(remark, {
          width: remarksWidth - 4,
          align: 'center',
        });
        const remarkCenterY =
          startY + (totalParamHeight - remarkTextHeight) / 2;
        doc.text(remark, remarksX + 2, remarkCenterY, {
          width: remarksWidth - 4,
          align: 'center',
        });

        // Draw bottom border for entire parameter group
        doc
          .moveTo(left, y)
          .lineTo(left + tableWidth, y)
          .stroke();
      } else {
        // No readings - just show a single parameter row
        doc.font('Helvetica').fontSize(9);

        let needsTopBorder = false;
        if (y + singleRowHeight > bottomLimit) {
          doc.addPage();
          y = doc.page.margins.top || 50;
          needsTopBorder = true;
        }

        // Draw top border if this is the first row on a new page
        if (needsTopBorder) {
          doc.strokeColor('#000000').lineWidth(0.5);
          doc
            .moveTo(left, y)
            .lineTo(left + tableWidth, y)
            .stroke();
        }

        // Draw borders
        doc.strokeColor('#000000').lineWidth(0.5);

        // Vertical borders
        doc
          .moveTo(parameterX, y)
          .lineTo(parameterX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(monthX, y)
          .lineTo(monthX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(currentX, y)
          .lineTo(currentX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(previousX, y)
          .lineTo(previousX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(mmtCurrentX, y)
          .lineTo(mmtCurrentX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(mmtPreviousX, y)
          .lineTo(mmtPreviousX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(redFlagX, y)
          .lineTo(redFlagX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(actionX, y)
          .lineTo(actionX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(limitX, y)
          .lineTo(limitX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(remarksX, y)
          .lineTo(remarksX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(remarksX + remarksWidth, y)
          .lineTo(remarksX + remarksWidth, y + singleRowHeight)
          .stroke();

        // Bottom border
        doc
          .moveTo(left, y + singleRowHeight)
          .lineTo(left + tableWidth, y + singleRowHeight)
          .stroke();

        // Parameter name (with text wrapping support)
        doc.font('Helvetica-Bold').fontSize(9);
        doc.text(paramName, parameterX + 2, y + 5, {
          width: parameterWidth - 4,
          align: 'center',
        });

        // Month
        doc.font('Helvetica').fontSize(9);
        doc.text(month, monthX + 2, y + 5, {
          width: monthWidth - 4,
          align: 'center',
        });

        // Current (empty)
        doc.text('', currentX + 2, y + 5, {
          width: currentWidth - 4,
          align: 'center',
        });

        // Previous (empty)
        doc.text('', previousX + 2, y + 5, {
          width: previousWidth - 4,
          align: 'center',
        });

        // MMT values
        doc.text(mmtCurrent, mmtCurrentX + 2, y + 5, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });

        doc.text(mmtPrevious, mmtPreviousX + 2, y + 5, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });

        // DENR Standard
        doc.text(redFlag, redFlagX + 2, y + 5, {
          width: redFlagWidth - 4,
          align: 'center',
        });

        doc.text(action, actionX + 2, y + 5, {
          width: actionWidth - 4,
          align: 'center',
        });

        doc.text(limit, limitX + 2, y + 5, {
          width: limitWidth - 4,
          align: 'center',
        });

        // Remark (with text wrapping support)
        doc.font('Helvetica').fontSize(8);
        doc.text(remark, remarksX + 2, y + 5, {
          width: remarksWidth - 4,
          align: 'center',
        });

        y += singleRowHeight;
      }
    }
  }

  // Port text (between tables)
  if (data.port) {
    doc.moveDown(4);
    y = doc.y;
    renderTextField('Port', data.port);
    doc.moveDown(2);
    y = doc.y;
  }

  // Render second table if parametersTable2 exists
  if (data.parametersTable2 && data.parametersTable2.length > 0) {
    // Re-draw header for second table
    const currentY2 = y;

    // Row 1: Parameter | Result | DENR Standard | Remark
    doc
      .font('Helvetica-Bold')
      .fontSize(11)
      .strokeColor('#000000')
      .lineWidth(0.5);

    // Outer borders for row 1
    doc
      .moveTo(left, currentY2)
      .lineTo(left + tableWidth, currentY2)
      .stroke(); // Top

    // Left edge of table
    doc
      .moveTo(parameterX, currentY2)
      .lineTo(parameterX, currentY2 + totalHeaderHeight)
      .stroke();

    // Parameter column border (right edge) - merged 3 rows
    doc
      .moveTo(monthX, currentY2)
      .lineTo(monthX, currentY2 + totalHeaderHeight)
      .stroke();

    // Parameter text
    const parameterText2 = 'Parameter';
    const parameterTextHeight2 = doc.heightOfString(parameterText2, {
      width: parameterWidth - 5,
      align: 'center',
    });
    const parameterCenteredY2 =
      currentY2 + (totalHeaderHeight - parameterTextHeight2) / 2;
    doc.text(parameterText2, parameterX + 2, parameterCenteredY2, {
      width: parameterWidth - 4,
      align: 'center',
    });

    // Result header
    const resultWidth2 =
      monthWidth +
      currentWidth +
      previousWidth +
      mmtCurrentWidth +
      mmtPreviousWidth;
    const resultX2 = monthX;
    doc
      .moveTo(resultX2 + resultWidth2, currentY2)
      .lineTo(resultX2 + resultWidth2, currentY2 + headerRow1Height)
      .stroke();
    doc.text('Result', resultX2 + 2, currentY2 + 4, {
      width: resultWidth2 - 4,
      align: 'center',
    });

    // DENR Standard header
    const denrWidth2 = redFlagWidth + actionWidth + limitWidth;
    const denrX2 = redFlagX;
    const denrMergedHeight2 = headerRow1Height + headerRow2Height;
    doc
      .moveTo(denrX2, currentY2)
      .lineTo(denrX2, currentY2 + denrMergedHeight2)
      .stroke();
    doc
      .moveTo(denrX2 + denrWidth2, currentY2)
      .lineTo(denrX2 + denrWidth2, currentY2 + denrMergedHeight2)
      .stroke();

    const denrText2 = 'DENR Standard';
    const denrTextHeight2 = doc.heightOfString(denrText2, {
      width: denrWidth2 - 4,
      align: 'center',
    });
    const denrCenteredY2 =
      currentY2 + (denrMergedHeight2 - denrTextHeight2) / 2;
    doc.text(denrText2, denrX2 + 2, denrCenteredY2, {
      width: denrWidth2 - 4,
      align: 'center',
    });

    // Remark column border
    doc
      .moveTo(remarksX, currentY2)
      .lineTo(remarksX, currentY2 + totalHeaderHeight)
      .stroke();

    // Right edge of table
    doc
      .moveTo(remarksX + remarksWidth, currentY2)
      .lineTo(remarksX + remarksWidth, currentY2 + totalHeaderHeight)
      .stroke();

    // Remark text
    const remarksText2 = 'Remark';
    const remarksTextHeight2 = doc.heightOfString(remarksText2, {
      width: remarksWidth - 5,
      align: 'center',
    });
    const remarksCenteredY2 =
      currentY2 + (totalHeaderHeight - remarksTextHeight2) / 2;
    doc.text(remarksText2, remarksX + 2, remarksCenteredY2, {
      width: remarksWidth - 4,
      align: 'center',
    });

    // Bottom of row 1
    doc
      .moveTo(monthX, currentY2 + headerRow1Height)
      .lineTo(denrX2, currentY2 + headerRow1Height)
      .stroke();

    // Row 2
    const row2Y2 = currentY2 + headerRow1Height;

    // Internal Monitoring
    const internalMonitoringWidth2 = monthWidth + currentWidth + previousWidth;
    const internalMonitoringX2 = monthX;
    doc
      .moveTo(internalMonitoringX2, row2Y2)
      .lineTo(internalMonitoringX2, row2Y2 + headerRow2Height)
      .stroke();
    doc
      .moveTo(internalMonitoringX2 + internalMonitoringWidth2, row2Y2)
      .lineTo(
        internalMonitoringX2 + internalMonitoringWidth2,
        row2Y2 + headerRow2Height,
      )
      .stroke();
    doc.text('Internal Monitoring', internalMonitoringX2 + 2, row2Y2 + 4, {
      width: internalMonitoringWidth2 - 4,
      align: 'center',
    });

    // MMT Confirmatory Sampling
    const mmtWidth2 = mmtCurrentWidth + mmtPreviousWidth;
    const mmtX2 = mmtCurrentX;
    doc
      .moveTo(mmtX2, row2Y2)
      .lineTo(mmtX2, row2Y2 + headerRow2Height)
      .stroke();
    doc
      .moveTo(mmtX2 + mmtWidth2, row2Y2)
      .lineTo(mmtX2 + mmtWidth2, row2Y2 + headerRow2Height)
      .stroke();
    doc.text('MMT Confirmatory Sampling', mmtX2 + 2, row2Y2 + 4, {
      width: mmtWidth2 - 4,
      align: 'center',
    });

    // Bottom of row 2
    doc
      .moveTo(monthX, row2Y2 + headerRow2Height)
      .lineTo(denrX2, row2Y2 + headerRow2Height)
      .stroke();

    doc
      .moveTo(denrX2, row2Y2 + headerRow2Height)
      .lineTo(remarksX, row2Y2 + headerRow2Height)
      .stroke();

    // Row 3
    const row3Y2 = row2Y2 + headerRow2Height;

    // Month
    doc
      .moveTo(monthX, row3Y2)
      .lineTo(monthX, row3Y2 + headerRow3Height)
      .stroke();
    doc
      .moveTo(currentX, row3Y2)
      .lineTo(currentX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Month', monthX + 2, row3Y2 + 5, {
      width: monthWidth - 4,
      align: 'center',
    });

    // Current (mg/L)
    doc
      .moveTo(previousX, row3Y2)
      .lineTo(previousX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Current', currentX + 2, row3Y2 + 3, {
      width: currentWidth - 4,
      align: 'center',
      lineBreak: false,
    });
    doc.text('(mg/L)', currentX + 2, row3Y2 + 12, {
      width: currentWidth - 4,
      align: 'center',
    });
    doc.font('Helvetica-Bold').fontSize(11);

    // Previous (mg/L)
    doc
      .moveTo(mmtCurrentX, row3Y2)
      .lineTo(mmtCurrentX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Previous', previousX + 2, row3Y2 + 3, {
      width: previousWidth - 4,
      align: 'center',
      lineBreak: false,
    });
    doc.text('(mg/L)', previousX + 2, row3Y2 + 12, {
      width: previousWidth - 4,
      align: 'center',
    });
    doc.font('Helvetica-Bold').fontSize(9);

    // MMT Current
    doc
      .moveTo(mmtPreviousX, row3Y2)
      .lineTo(mmtPreviousX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Current', mmtCurrentX + 2, row3Y2 + 5, {
      width: mmtCurrentWidth - 4,
      align: 'center',
    });

    // MMT Previous
    doc
      .moveTo(redFlagX, row3Y2)
      .lineTo(redFlagX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Previous', mmtPreviousX + 2, row3Y2 + 5, {
      width: mmtPreviousWidth - 4,
      align: 'center',
    });

    // Red Flag
    doc
      .moveTo(actionX, row3Y2)
      .lineTo(actionX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Red Flag', redFlagX + 2, row3Y2 + 7, {
      width: redFlagWidth - 4,
      align: 'center',
    });

    // Action
    doc
      .moveTo(limitX, row3Y2)
      .lineTo(limitX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Action', actionX + 2, row3Y2 + 7, {
      width: actionWidth - 4,
      align: 'center',
    });

    // Limit mg/L
    doc
      .moveTo(remarksX, row3Y2)
      .lineTo(remarksX, row3Y2 + headerRow3Height)
      .stroke();
    doc.text('Limit', limitX + 2, row3Y2 + 3, {
      width: limitWidth - 4,
      align: 'center',
      lineBreak: false,
    });
    doc.text('mg/L', limitX + 2, row3Y2 + 12, {
      width: limitWidth - 4,
      align: 'center',
    });
    doc.font('Helvetica-Bold').fontSize(11);

    // Bottom of row 3
    doc
      .moveTo(left, row3Y2 + headerRow3Height)
      .lineTo(left + tableWidth, row3Y2 + headerRow3Height)
      .stroke();

    y = currentY2 + totalHeaderHeight;

    // Data rows for second table (same logic as first table)
    for (const param of data.parametersTable2) {
      const paramName = param.name || '';
      const month = param.result?.internalMonitoring?.month || '';
      const readings = param.result?.internalMonitoring?.readings || [];
      const mmtCurrent = param.result?.mmtConfirmatorySampling?.current || '-';
      const mmtPrevious =
        param.result?.mmtConfirmatorySampling?.previous || '-';
      const redFlag = param.denrStandard?.redFlag || '-';
      const action = param.denrStandard?.action || '-';
      const limit = param.denrStandard?.limit_mgL
        ? param.denrStandard.limit_mgL.toString()
        : '-';
      const remark = param.remark || '';

      doc.font('Helvetica-Bold').fontSize(9);
      const paramTextHeight = doc.heightOfString(paramName, {
        width: parameterWidth - 4,
        align: 'center',
      });

      doc.font('Helvetica').fontSize(8);
      const remarkTextHeight = doc.heightOfString(remark, {
        width: remarksWidth - 4,
        align: 'center',
      });

      const readingCount = readings.length > 0 ? readings.length : 1;
      const minRowHeight = 27;
      const singleRowHeight = Math.max(
        minRowHeight,
        paramTextHeight + 6,
        remarkTextHeight + 6,
      );
      const totalParamHeight = singleRowHeight * readingCount;

      let needsTopBorder = false;
      if (y + totalParamHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        needsTopBorder = true;
      }

      const startY = y;

      if (needsTopBorder) {
        doc.strokeColor('#000000').lineWidth(0.5);
        doc
          .moveTo(left, y)
          .lineTo(left + tableWidth, y)
          .stroke();
      }

      if (readings && readings.length > 0) {
        // Draw vertical borders for the entire parameter group
        doc.strokeColor('#000000').lineWidth(0.5);
        doc
          .moveTo(parameterX, y)
          .lineTo(parameterX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(monthX, y)
          .lineTo(monthX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(currentX, y)
          .lineTo(currentX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(previousX, y)
          .lineTo(previousX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(mmtCurrentX, y)
          .lineTo(mmtCurrentX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(mmtPreviousX, y)
          .lineTo(mmtPreviousX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(redFlagX, y)
          .lineTo(redFlagX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(actionX, y)
          .lineTo(actionX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(limitX, y)
          .lineTo(limitX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(remarksX, y)
          .lineTo(remarksX, y + totalParamHeight)
          .stroke();
        doc
          .moveTo(remarksX + remarksWidth, y)
          .lineTo(remarksX + remarksWidth, y + totalParamHeight)
          .stroke();

        // Draw readings rows
        for (let i = 0; i < readings.length; i++) {
          const reading = readings[i];
          const label = reading.label || '';
          const currentMgL =
            reading.current_mgL !== undefined
              ? reading.current_mgL.toString()
              : '-';
          const previousMgL =
            reading.previous_mgL !== undefined
              ? reading.previous_mgL.toString()
              : '-';

          // Current column: Display label and value separated by a line
          const labelWidthRatio = 0.5; // 50% for label, 50% for value
          const currentLabelWidth = currentWidth * labelWidthRatio;
          const currentValueWidth = currentWidth * (1 - labelWidthRatio);
          const currentLabelX = currentX;
          const currentValueX = currentX + currentLabelWidth;

          // Draw vertical separator line in Current column
          doc
            .moveTo(currentValueX, y)
            .lineTo(currentValueX, y + singleRowHeight)
            .stroke();

          doc.font('Helvetica').fontSize(10);

          // Label (left side)
          doc.text(label, currentLabelX + 2, y + 5, {
            width: currentLabelWidth - 4,
            align: 'center',
          });

          doc.fontSize(11);

          // Value (right side)
          doc.text(currentMgL, currentValueX + 2, y + 5, {
            width: currentValueWidth - 4,
            align: 'center',
          });

          // Previous column: Display label and value separated by a line
          const previousLabelWidth = previousWidth * labelWidthRatio;
          const previousValueWidth = previousWidth * (1 - labelWidthRatio);
          const previousLabelX = previousX;
          const previousValueX = previousX + previousLabelWidth;

          // Draw vertical separator line in Previous column
          doc
            .moveTo(previousValueX, y)
            .lineTo(previousValueX, y + singleRowHeight)
            .stroke();

          doc.fontSize(10);

          // Label (left side)
          doc.text(label, previousLabelX + 2, y + 5, {
            width: previousLabelWidth - 4,
            align: 'center',
          });

          doc.fontSize(11);

          // Value (right side)
          doc.text(previousMgL, previousValueX + 2, y + 5, {
            width: previousValueWidth - 4,
            align: 'center',
          });

          // Draw horizontal line between readings
          if (i < readings.length - 1) {
            doc
              .moveTo(currentX, y + singleRowHeight)
              .lineTo(previousX + previousWidth, y + singleRowHeight)
              .stroke();
          }

          y += singleRowHeight;
        }

        // Draw merged cells content
        doc.font('Helvetica-Bold').fontSize(9);
        const paramTextHeight2 = doc.heightOfString(paramName, {
          width: parameterWidth - 4,
          align: 'center',
        });
        const paramCenterY = startY + (totalParamHeight - paramTextHeight2) / 2;
        doc.text(paramName, parameterX + 2, paramCenterY, {
          width: parameterWidth - 4,
          align: 'center',
        });

        doc.font('Helvetica').fontSize(11);
        const monthTextHeight = doc.heightOfString(month, {
          width: monthWidth - 4,
          align: 'center',
        });
        const monthCenterY = startY + (totalParamHeight - monthTextHeight) / 2;
        doc.text(month, monthX + 2, monthCenterY, {
          width: monthWidth - 4,
          align: 'center',
        });

        const mmtCurrentTextHeight = doc.heightOfString(mmtCurrent, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });
        const mmtCurrentCenterY =
          startY + (totalParamHeight - mmtCurrentTextHeight) / 2;
        doc.text(mmtCurrent, mmtCurrentX + 2, mmtCurrentCenterY, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });

        const mmtPreviousTextHeight = doc.heightOfString(mmtPrevious, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });
        const mmtPreviousCenterY =
          startY + (totalParamHeight - mmtPreviousTextHeight) / 2;
        doc.text(mmtPrevious, mmtPreviousX + 2, mmtPreviousCenterY, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });

        const redFlagTextHeight = doc.heightOfString(redFlag, {
          width: redFlagWidth - 4,
          align: 'center',
        });
        const redFlagCenterY =
          startY + (totalParamHeight - redFlagTextHeight) / 2;
        doc.text(redFlag, redFlagX + 2, redFlagCenterY, {
          width: redFlagWidth - 4,
          align: 'center',
        });

        const actionTextHeight = doc.heightOfString(action, {
          width: actionWidth - 4,
          align: 'center',
        });
        const actionCenterY =
          startY + (totalParamHeight - actionTextHeight) / 2;
        doc.text(action, actionX + 2, actionCenterY, {
          width: actionWidth - 4,
          align: 'center',
        });

        const limitTextHeight = doc.heightOfString(limit, {
          width: limitWidth - 4,
          align: 'center',
        });
        const limitCenterY = startY + (totalParamHeight - limitTextHeight) / 2;
        doc.text(limit, limitX + 2, limitCenterY, {
          width: limitWidth - 4,
          align: 'center',
        });

        const remarkTextHeight2 = doc.heightOfString(remark, {
          width: remarksWidth - 4,
          align: 'center',
        });
        const remarkCenterY =
          startY + (totalParamHeight - remarkTextHeight2) / 2;
        doc.text(remark, remarksX + 2, remarkCenterY, {
          width: remarksWidth - 4,
          align: 'center',
        });

        doc
          .moveTo(left, y)
          .lineTo(left + tableWidth, y)
          .stroke();
      } else {
        // No readings - single row
        doc.font('Helvetica').fontSize(9);

        let needsTopBorder2 = false;
        if (y + singleRowHeight > bottomLimit) {
          doc.addPage();
          y = doc.page.margins.top || 50;
          needsTopBorder2 = true;
        }

        if (needsTopBorder2) {
          doc.strokeColor('#000000').lineWidth(0.5);
          doc
            .moveTo(left, y)
            .lineTo(left + tableWidth, y)
            .stroke();
        }

        doc.strokeColor('#000000').lineWidth(0.5);

        doc
          .moveTo(parameterX, y)
          .lineTo(parameterX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(monthX, y)
          .lineTo(monthX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(currentX, y)
          .lineTo(currentX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(previousX, y)
          .lineTo(previousX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(mmtCurrentX, y)
          .lineTo(mmtCurrentX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(mmtPreviousX, y)
          .lineTo(mmtPreviousX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(redFlagX, y)
          .lineTo(redFlagX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(actionX, y)
          .lineTo(actionX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(limitX, y)
          .lineTo(limitX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(remarksX, y)
          .lineTo(remarksX, y + singleRowHeight)
          .stroke();
        doc
          .moveTo(remarksX + remarksWidth, y)
          .lineTo(remarksX + remarksWidth, y + singleRowHeight)
          .stroke();

        doc.font('Helvetica-Bold').fontSize(9);
        const paramTextHeight3 = doc.heightOfString(paramName, {
          width: parameterWidth - 4,
          align: 'center',
        });
        const paramCenterY2 = y + (singleRowHeight - paramTextHeight3) / 2;
        doc.text(paramName, parameterX + 2, paramCenterY2, {
          width: parameterWidth - 4,
          align: 'center',
        });

        doc.font('Helvetica').fontSize(8);
        const monthTextHeight2 = doc.heightOfString(month, {
          width: monthWidth - 4,
          align: 'center',
        });
        const monthCenterY2 = y + (singleRowHeight - monthTextHeight2) / 2;
        doc.text(month, monthX + 2, monthCenterY2, {
          width: monthWidth - 4,
          align: 'center',
        });

        doc.text('-', currentX + 2, y + 5, {
          width: currentWidth - 4,
          align: 'center',
        });

        doc.text('-', previousX + 2, y + 5, {
          width: previousWidth - 4,
          align: 'center',
        });

        const mmtCurrentTextHeight2 = doc.heightOfString(mmtCurrent, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });
        const mmtCurrentCenterY2 =
          y + (singleRowHeight - mmtCurrentTextHeight2) / 2;
        doc.text(mmtCurrent, mmtCurrentX + 2, mmtCurrentCenterY2, {
          width: mmtCurrentWidth - 4,
          align: 'center',
        });

        const mmtPreviousTextHeight2 = doc.heightOfString(mmtPrevious, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });
        const mmtPreviousCenterY2 =
          y + (singleRowHeight - mmtPreviousTextHeight2) / 2;
        doc.text(mmtPrevious, mmtPreviousX + 2, mmtPreviousCenterY2, {
          width: mmtPreviousWidth - 4,
          align: 'center',
        });

        doc.text(redFlag, redFlagX + 2, y + 5, {
          width: redFlagWidth - 4,
          align: 'center',
        });

        doc.text(action, actionX + 2, y + 5, {
          width: actionWidth - 4,
          align: 'center',
        });

        doc.text(limit, limitX + 2, y + 5, {
          width: limitWidth - 4,
          align: 'center',
        });

        doc.font('Helvetica').fontSize(8);
        doc.text(remark, remarksX + 2, y + 5, {
          width: remarksWidth - 4,
          align: 'center',
        });

        y += singleRowHeight;
      }
    }
  }

  // Footer rows - similar to air quality
  const footerRows = [
    ['Date/ Time of sampling', data.samplingDate || ''],
    ['Weather and wind direction', data.weatherAndWind || ''],
    [
      'Explanation of why confirmatory sampling was conducted for specific parameter in the sampling station',
      data.explanationForConfirmatorySampling || '',
    ],
  ];

  for (const [label, value] of footerRows) {
    const combinedText = `${label}: ${value}`;
    doc.font('Helvetica').fontSize(11);
    const textHeight = doc.heightOfString(combinedText, {
      width: tableWidth - 10,
      align: 'left',
    });
    const rowHeight = Math.max(14, textHeight) + 4;

    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
    }

    // Draw borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    doc.text(combinedText, left + 5, y + (rowHeight - textHeight) / 2, {
      width: tableWidth - 10,
      align: 'left',
    });

    y += rowHeight;
  }

  // Overall Assessment row (bold value)
  if (data.overallAssessment) {
    const label = 'Overall Assessment';
    const value = data.overallAssessment;
    const fullText = `${label}: ${value}`;

    doc.font('Helvetica').fontSize(11);
    const textHeight = doc.heightOfString(fullText, {
      width: tableWidth - 10,
      align: 'center',
    });
    const rowHeight = Math.max(14, textHeight) + 4;

    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
    }

    // Draw borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Calculate position for centered text
    const textY = y + (rowHeight - textHeight) / 2;

    // Calculate widths for positioning
    doc.font('Helvetica').fontSize(11);
    const labelWidth = doc.widthOfString(`${label}: `);

    // Center the entire text block
    const totalWidth =
      doc.widthOfString(label + ': ') +
      doc.font('Helvetica-Bold').widthOfString(value);
    const startX = left + (tableWidth - totalWidth) / 2;

    // Draw label
    doc.font('Helvetica').fontSize(11);
    doc.text(`${label}: `, startX, textY, {
      continued: true,
      lineBreak: false,
    });

    // Draw bold value
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text(value);

    y += rowHeight;
  }

  doc.y = y;
  doc.moveDown(0.5);
}

/**
 * Draw Noise Quality Impact Assessment table
 */
export function drawNoiseQualityImpactAssessmentTable(
  doc: PDFKit.PDFDocument,
  data: {
    parameters?: Array<{
      name?: string;
      results?: {
        inSMR?: {
          current?: string;
          previous?: string;
        };
        mmtConfirmatorySampling?: {
          current?: string;
          previous?: string;
        };
      };
      eqpl?: {
        redFlag?: string;
        action?: string;
        denrStandard?: string;
      };
      remarks?: string;
    }>;
    samplingDate?: string;
    weatherAndWind?: string;
    explanationForConfirmatorySampling?: string;
    overallAssessment?: {
      firstQuarter?: {
        year?: string;
        assessment?: string;
      };
      secondQuarter?: {
        year?: string;
        assessment?: string;
      };
      thirdQuarter?: {
        year?: string;
        assessment?: string;
      };
      fourthQuarter?: {
        year?: string;
        assessment?: string;
      };
    };
  },
) {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  const parameters = data.parameters ?? [];

  if (parameters.length > 0) {
    // Multi-row header structure with 3 rows
    // Row 1: Parameter | Results (merged) | EQPL (merged) | Remarks
    // Row 2: Parameter | In SMR (merged) | MMT Confirmatory Sampling (merged) | Red Flag | Action | DENR Standard Class C - Daytime | Remarks
    // Row 3: Parameter | Current | Previous | Current | Previous | Red Flag | Action | DENR Standard Class C - Daytime | Remarks

    const columnWidths = [0.15, 0.1, 0.1, 0.1, 0.1, 0.08, 0.08, 0.14, 0.15];
    const colWidths = columnWidths.map((pct) => tableWidth * pct);

    let y = doc.y;
    const topMargin = doc.page.margins.top || 50;
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

    const headerRow1Height = 16;
    const headerRow2Height = 32;
    const headerRow3Height = 16;
    const totalHeaderHeight =
      headerRow1Height + headerRow2Height + headerRow3Height;

    if (y + totalHeaderHeight > bottomLimit) {
      doc.addPage();
      y = topMargin;
    }

    const startY = y;
    doc.strokeColor('#000000').lineWidth(0.5);
    doc.font('Helvetica-Bold').fontSize(9);

    // Calculate column positions
    const parameterX = left;
    const inSMRCurrentX = left + colWidths[0];
    const inSMRPreviousX = inSMRCurrentX + colWidths[1];
    const mmtCurrentX = inSMRPreviousX + colWidths[2];
    const mmtPreviousX = mmtCurrentX + colWidths[3];
    const redFlagX = mmtPreviousX + colWidths[4];
    const actionX = redFlagX + colWidths[5];
    const denrStandardX = actionX + colWidths[6];
    const remarksX = denrStandardX + colWidths[7];

    // Outer border
    doc.rect(left, startY, tableWidth, totalHeaderHeight).stroke();

    // ===== ROW 1 =====
    // Parameter (spans 3 rows)
    const parameterWidth = colWidths[0];
    doc
      .moveTo(parameterX + parameterWidth, startY)
      .lineTo(parameterX + parameterWidth, startY + totalHeaderHeight)
      .stroke();
    const paramText = 'Parameter';
    const paramTextHeight = doc.heightOfString(paramText, {
      width: parameterWidth - 4,
      align: 'center',
    });
    const paramTextY = startY + (totalHeaderHeight - paramTextHeight) / 2;
    doc.text(paramText, parameterX + 2, paramTextY, {
      width: parameterWidth - 4,
      align: 'center',
    });

    // Results (merged: spans inSMRCurrent, inSMRPrevious, mmtCurrent, mmtPrevious)
    const resultsWidth =
      colWidths[1] + colWidths[2] + colWidths[3] + colWidths[4];
    doc
      .moveTo(mmtPreviousX + colWidths[4], startY)
      .lineTo(mmtPreviousX + colWidths[4], startY + headerRow1Height)
      .stroke();
    doc
      .moveTo(inSMRCurrentX, startY + headerRow1Height)
      .lineTo(mmtPreviousX + colWidths[4], startY + headerRow1Height)
      .stroke();
    doc.text('Results', inSMRCurrentX + 2, startY + 5, {
      width: resultsWidth - 4,
      align: 'center',
    });

    // EQPL (merged: spans redFlag, action, denrStandard)
    const eqplWidth = colWidths[5] + colWidths[6] + colWidths[7];
    doc
      .moveTo(remarksX, startY)
      .lineTo(remarksX, startY + headerRow1Height)
      .stroke();
    doc
      .moveTo(redFlagX, startY + headerRow1Height)
      .lineTo(remarksX, startY + headerRow1Height)
      .stroke();
    doc.text('EQPL', redFlagX + 2, startY + 5, {
      width: eqplWidth - 4,
      align: 'center',
    });

    // Remarks (spans 3 rows)
    const remarksWidth = colWidths[8];
    const remarksText = 'Remarks';
    const remarksTextHeight = doc.heightOfString(remarksText, {
      width: remarksWidth - 4,
      align: 'center',
    });
    const remarksTextY = startY + (totalHeaderHeight - remarksTextHeight) / 2;
    doc.text(remarksText, remarksX + 2, remarksTextY, {
      width: remarksWidth - 4,
      align: 'center',
    });

    // ===== ROW 2 =====
    const row2Y = startY + headerRow1Height;

    // In SMR (merged: spans current and previous)
    const inSMRWidth = colWidths[1] + colWidths[2];
    doc
      .moveTo(inSMRPreviousX + colWidths[2], row2Y)
      .lineTo(inSMRPreviousX + colWidths[2], row2Y + headerRow2Height)
      .stroke();
    doc.text('In SMR', inSMRCurrentX + 2, row2Y + 5, {
      width: inSMRWidth - 4,
      align: 'center',
    });

    // MMT Confirmatory Sampling (merged: spans current and previous)
    const mmtWidth = colWidths[3] + colWidths[4];
    doc
      .moveTo(mmtPreviousX + colWidths[4], row2Y)
      .lineTo(mmtPreviousX + colWidths[4], row2Y + headerRow2Height)
      .stroke();
    const mmtText = 'MMT Confirmatory\nSampling';
    const mmtTextHeight = doc.heightOfString(mmtText, {
      width: mmtWidth - 4,
      align: 'center',
    });
    const mmtTextY = row2Y + (headerRow2Height - mmtTextHeight) / 2;
    doc.text(mmtText, mmtCurrentX + 2, mmtTextY, {
      width: mmtWidth - 4,
      align: 'center',
    });

    // Vertical divider between DENR Standard and Remarks (row 2)
    doc
      .moveTo(remarksX, row2Y)
      .lineTo(remarksX, row2Y + headerRow2Height)
      .stroke();

    // Horizontal divider under row 2 for Results section
    doc
      .moveTo(inSMRCurrentX, row2Y + headerRow2Height)
      .lineTo(mmtPreviousX + colWidths[4], row2Y + headerRow2Height)
      .stroke();

    // Red Flag (spans rows 2 and 3)
    doc
      .moveTo(actionX, row2Y)
      .lineTo(actionX, startY + totalHeaderHeight)
      .stroke();
    const redFlagText = 'Red\nFlag';
    const redFlagTextHeight = doc.heightOfString(redFlagText, {
      width: colWidths[5] - 4,
      align: 'center',
    });
    const redFlagTextY =
      row2Y + (headerRow2Height + headerRow3Height - redFlagTextHeight) / 2;
    doc.text(redFlagText, redFlagX + 2, redFlagTextY, {
      width: colWidths[5] - 4,
      align: 'center',
    });

    // Action (spans rows 2 and 3)
    doc
      .moveTo(denrStandardX, row2Y)
      .lineTo(denrStandardX, startY + totalHeaderHeight)
      .stroke();
    const actionText = 'Action';
    const actionTextHeight = doc.heightOfString(actionText, {
      width: colWidths[6] - 4,
      align: 'center',
    });
    const actionTextY =
      row2Y + (headerRow2Height + headerRow3Height - actionTextHeight) / 2;
    doc.text(actionText, actionX + 2, actionTextY, {
      width: colWidths[6] - 4,
      align: 'center',
    });

    // DENR Standard Class C - Daytime (spans rows 2 and 3)
    const denrText = 'DENR Standard Class C - Daytime';
    const denrTextHeight = doc.heightOfString(denrText, {
      width: colWidths[7] - 4,
      align: 'center',
    });
    const denrTextY =
      row2Y + (headerRow2Height + headerRow3Height - denrTextHeight) / 2;
    doc.text(denrText, denrStandardX + 2, denrTextY, {
      width: colWidths[7] - 4,
      align: 'center',
    });

    // ===== ROW 3 =====
    const row3Y = row2Y + headerRow2Height;

    // Vertical divider between In SMR Current and Previous (row 3)
    doc
      .moveTo(inSMRPreviousX, row3Y)
      .lineTo(inSMRPreviousX, startY + totalHeaderHeight)
      .stroke();

    // Vertical divider between In SMR Previous and MMT Current (row 3)
    doc
      .moveTo(mmtCurrentX, row3Y)
      .lineTo(mmtCurrentX, startY + totalHeaderHeight)
      .stroke();

    // Vertical divider between MMT Current and Previous (row 3)
    doc
      .moveTo(mmtPreviousX, row3Y)
      .lineTo(mmtPreviousX, startY + totalHeaderHeight)
      .stroke();

    // Vertical divider between Previous and Red Flag (row 3)
    doc
      .moveTo(redFlagX, row3Y)
      .lineTo(redFlagX, startY + totalHeaderHeight)
      .stroke();

    // Vertical divider between DENR Standard and Remarks (row 3)
    doc
      .moveTo(remarksX, row3Y)
      .lineTo(remarksX, startY + totalHeaderHeight)
      .stroke();

    // Current label under In SMR
    doc.text('Current', inSMRCurrentX + 2, row3Y + 4, {
      width: colWidths[1] - 4,
      align: 'center',
    });

    // Previous label under In SMR
    doc.text('Previous', inSMRPreviousX + 2, row3Y + 4, {
      width: colWidths[2] - 4,
      align: 'center',
    });

    // Current label under MMT Confirmatory Sampling
    doc.text('Current', mmtCurrentX + 2, row3Y + 4, {
      width: colWidths[3] - 4,
      align: 'center',
    });

    // Previous label under MMT Confirmatory Sampling
    doc.text('Previous', mmtPreviousX + 2, row3Y + 4, {
      width: colWidths[4] - 4,
      align: 'center',
    });

    y = startY + totalHeaderHeight;

    // Data rows
    doc.font('Helvetica').fontSize(10);
    for (const param of parameters) {
      const name = param.name || '';
      const currentInSMR = param.results?.inSMR?.current || '-';
      const previousInSMR = param.results?.inSMR?.previous || '-';
      const currentMMT = param.results?.mmtConfirmatorySampling?.current || '-';
      const previousMMT =
        param.results?.mmtConfirmatorySampling?.previous || '-';
      const redFlag = param.eqpl?.redFlag || '-';
      const action = param.eqpl?.action || '-';
      const denrStandard = param.eqpl?.denrStandard || '-';
      const remarks = param.remarks || '-';

      // Calculate row height
      const cellTexts = [
        name,
        currentInSMR,
        previousInSMR,
        currentMMT,
        previousMMT,
        redFlag,
        action,
        denrStandard,
        remarks,
      ];
      const cellHeights = cellTexts.map((text, idx) =>
        doc.heightOfString(text, {
          width: colWidths[idx] - 4,
          align: 'center',
        }),
      );
      const rowHeight = Math.max(14, ...cellHeights) + 6;

      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = topMargin;
      }

      // Draw row borders
      doc.rect(left, y, tableWidth, rowHeight).stroke();

      // Column dividers
      const columnXPositions = [
        inSMRCurrentX,
        inSMRPreviousX,
        mmtCurrentX,
        mmtPreviousX,
        redFlagX,
        actionX,
        denrStandardX,
        remarksX,
      ];

      for (const xPos of columnXPositions) {
        doc
          .moveTo(xPos, y)
          .lineTo(xPos, y + rowHeight)
          .stroke();
      }

      // Cell text
      const cellData = [
        { text: name, x: parameterX, width: colWidths[0] },
        { text: currentInSMR, x: inSMRCurrentX, width: colWidths[1] },
        { text: previousInSMR, x: inSMRPreviousX, width: colWidths[2] },
        { text: currentMMT, x: mmtCurrentX, width: colWidths[3] },
        { text: previousMMT, x: mmtPreviousX, width: colWidths[4] },
        { text: redFlag, x: redFlagX, width: colWidths[5] },
        { text: action, x: actionX, width: colWidths[6] },
        { text: denrStandard, x: denrStandardX, width: colWidths[7] },
        { text: remarks, x: remarksX, width: colWidths[8] },
      ];

      for (let i = 0; i < cellData.length; i++) {
        const { text, x, width } = cellData[i];
        const textY = y + (rowHeight - cellHeights[i]) / 2;
        doc.text(text, x + 2, textY, {
          width: width - 4,
          align: 'center',
        });
      }

      y += rowHeight;
    }

    // Additional info rows as table cells (similar to water quality footer rows)
    const additionalInfoRows: Array<{ label: string; value: string }> = [];
    if (data.samplingDate) {
      additionalInfoRows.push({
        label: 'Date/ time of sampling',
        value: data.samplingDate,
      });
    }
    if (data.weatherAndWind) {
      additionalInfoRows.push({
        label: 'Weather and wind direction',
        value: data.weatherAndWind,
      });
    }
    if (data.explanationForConfirmatorySampling) {
      additionalInfoRows.push({
        label:
          'Explanation of why confirmatory sampling was conducted for specific parameter in the sampling station',
        value: data.explanationForConfirmatorySampling,
      });
    }

    // Draw additional info rows as table footer rows
    doc.font('Helvetica').fontSize(11);
    for (const { label, value } of additionalInfoRows) {
      const combinedText = `${label}: ${value}`;
      const textHeight = doc.heightOfString(combinedText, {
        width: tableWidth - 10,
        align: 'left',
      });
      const rowHeight = Math.max(14, textHeight) + 4;

      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = topMargin;
      }

      // Draw borders
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + rowHeight)
        .stroke();
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      doc.text(combinedText, left + 5, y + (rowHeight - textHeight) / 2, {
        width: tableWidth - 10,
        align: 'left',
      });

      y += rowHeight;
    }

    doc.y = y;
    doc.moveDown(0.5);
  }

  // Overall Assessment Table (quarterly)
  if (data.overallAssessment) {
    doc.moveDown(0.5);

    const quarters = [
      data.overallAssessment.firstQuarter,
      data.overallAssessment.secondQuarter,
      data.overallAssessment.thirdQuarter,
      data.overallAssessment.fourthQuarter,
    ];

    const validQuarters = quarters.filter((q) => q && (q.year || q.assessment));

    if (validQuarters.length > 0) {
      // Label column (30%) + 4 equal columns for each quarter (17.5% each)
      const columnWidths = [0.2, 0.2, 0.2, 0.2, 0.2];
      const colWidths = columnWidths.map((pct) => tableWidth * pct);

      let y = doc.y;
      const topMargin = doc.page.margins.top || 50;
      const bottomLimit =
        doc.page.height - (doc.page.margins.bottom || 50) - 30;

      const headerRow1Height = 20;
      const headerRow2Height = 20;
      const totalHeaderHeight = headerRow1Height + headerRow2Height;

      if (y + totalHeaderHeight > bottomLimit) {
        doc.addPage();
        y = topMargin;
      }

      const startY = y;
      doc.strokeColor('#000000').lineWidth(0.5);
      doc.font('Helvetica-Bold').fontSize(9);

      // Column positions
      const labelX = left;
      const col1X = left + colWidths[0];
      const col2X = left + colWidths[0] + colWidths[1];
      const col3X = left + colWidths[0] + colWidths[1] + colWidths[2];
      const col4X =
        left + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3];

      // Outer border
      doc.rect(left, startY, tableWidth, totalHeaderHeight).stroke();

      // ===== ROW 1: Quarter headers with years =====
      // Draw vertical dividers
      doc
        .moveTo(col1X, startY)
        .lineTo(col1X, startY + totalHeaderHeight)
        .stroke();
      doc
        .moveTo(col2X, startY)
        .lineTo(col2X, startY + totalHeaderHeight)
        .stroke();
      doc
        .moveTo(col3X, startY)
        .lineTo(col3X, startY + totalHeaderHeight)
        .stroke();
      doc
        .moveTo(col4X, startY)
        .lineTo(col4X, startY + totalHeaderHeight)
        .stroke();

      // Horizontal divider after row 1 (only for quarter columns, not label)
      doc
        .moveTo(col1X, startY + headerRow1Height)
        .lineTo(left + tableWidth, startY + headerRow1Height)
        .stroke();

      // Row 1: Label + Quarter headers
      const labelText = 'Overall Noise\nQuality Impact\nAssessment';
      const labelTextHeight = doc.heightOfString(labelText, {
        width: colWidths[0] - 4,
        align: 'center',
      });
      const labelY = startY + (totalHeaderHeight - labelTextHeight) / 2;
      doc.text(labelText, labelX + 2, labelY, {
        width: colWidths[0] - 4,
        align: 'center',
      });

      const q1Header = `1st Quarter ${quarters[0]?.year || 'Year'}`;
      const q2Header = `2nd Quarter ${quarters[1]?.year || '2025'}`;
      const q3Header = `3rd Quarter ${quarters[2]?.year || '2025'}`;
      const q4Header = `4th Quarter ${quarters[3]?.year || '2025'}`;

      doc.text(q1Header, col1X + 2, startY + 5, {
        width: colWidths[1] - 4,
        align: 'center',
      });
      doc.text(q2Header, col2X + 2, startY + 5, {
        width: colWidths[2] - 4,
        align: 'center',
      });
      doc.text(q3Header, col3X + 2, startY + 5, {
        width: colWidths[3] - 4,
        align: 'center',
      });
      doc.text(q4Header, col4X + 2, startY + 5, {
        width: colWidths[4] - 4,
        align: 'center',
      });

      // ===== ROW 2: Assessment values =====
      const row2Y = startY + headerRow1Height;

      const q1Assessment = quarters[0]?.assessment || '1ST QUARTER';
      const q2Assessment = quarters[1]?.assessment || '2ND QUARTER';
      const q3Assessment = quarters[2]?.assessment || '3RD QUARTER';
      const q4Assessment = quarters[3]?.assessment || '4TH QUARTER';

      doc.text(q1Assessment, col1X + 2, row2Y + 5, {
        width: colWidths[1] - 4,
        align: 'center',
      });
      doc.text(q2Assessment, col2X + 2, row2Y + 5, {
        width: colWidths[2] - 4,
        align: 'center',
      });
      doc.text(q3Assessment, col3X + 2, row2Y + 5, {
        width: colWidths[3] - 4,
        align: 'center',
      });
      doc.text(q4Assessment, col4X + 2, row2Y + 5, {
        width: colWidths[4] - 4,
        align: 'center',
      });

      y = startY + totalHeaderHeight;
      doc.y = y;
      doc.moveDown(0.5);
    }
  }
}

/**
 * Draw Compliance with Good Practice in Solid and Hazardous Waste Management table
 */
export function drawSolidAndHazardousWasteManagementTable(
  doc: PDFKit.PDFDocument,
  data: {
    quarry?:
      | string
      | Array<{
          typeOfWaste?: string;
          eccEpepCommitments?: {
            handling?: string;
            storage?: string;
            disposal?: boolean;
          };
          adequate?: {
            y?: boolean;
            n?: boolean;
          };
          previousRecord?: string | Record<string, number>;
          q2_2025_Generated_HW?: string | Record<string, number>;
          total?: string | Record<string, number>;
        }>;
    plant?:
      | string
      | Array<{
          typeOfWaste?: string;
          eccEpepCommitments?: {
            handling?: string;
            storage?: string;
            disposal?: boolean;
          };
          adequate?: {
            y?: boolean;
            n?: boolean;
          };
          previousRecord?: string | Record<string, number>;
          q2_2025_Generated_HW?: string | Record<string, number>;
          total?: string | Record<string, number>;
        }>;
    port?:
      | string
      | Array<{
          typeOfWaste?: string;
          eccEpepCommitments?: {
            handling?: string;
            storage?: string;
            disposal?: boolean;
          };
          adequate?: {
            y?: boolean;
            n?: boolean;
          };
          previousRecord?: string | Record<string, number>;
          q2_2025_Generated_HW?: string | Record<string, number>;
          total?: string | Record<string, number>;
        }>;
  },
) {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  let y = doc.y;

  // Quarry - can be text or table
  if (data.quarry) {
    if (typeof data.quarry === 'string') {
      // Display as text
      const textIndent = 60;
      doc.font('Helvetica-Bold').fontSize(11);
      doc.text('Quarry: ', left + textIndent, y, {
        continued: true,
        lineBreak: false,
      });
      doc.font('Helvetica').fontSize(11);
      doc.text(data.quarry);
      y = doc.y;
      doc.moveDown(2);
      y = doc.y;
    }
  }

  // Helper function to render a waste management table
  const renderWasteTable = (
    title: string,
    items: Array<{
      typeOfWaste?: string;
      eccEpepCommitments?: {
        handling?: string;
        storage?: string;
        disposal?: boolean;
      };
      adequate?: {
        y?: boolean;
        n?: boolean;
      };
      previousRecord?: string | Record<string, number>;
      q2_2025_Generated_HW?: string | Record<string, number>;
      total?: string | Record<string, number>;
    }>,
  ) => {
    // Display title
    doc.font('Helvetica-Bold').fontSize(11);
    doc.text(title, left, y, {
      align: 'center',
    });
    y = doc.y;
    doc.moveDown(1);
    y = doc.y;

    // Column widths
    const typeOfWasteWidth = tableWidth * 0.15;
    const handlingWidth = tableWidth * 0.12;
    const storageWidth = tableWidth * 0.12;
    const disposalWidth = tableWidth * 0.12;
    const adequateYWidth = tableWidth * 0.06;
    const adequateNWidth = tableWidth * 0.06;
    const previousRecordWidth = tableWidth * 0.12;
    const q2GeneratedWidth = tableWidth * 0.13;
    const totalWidth2 = tableWidth * 0.12;

    // Column X positions
    const typeOfWasteX = left;
    const handlingX = typeOfWasteX + typeOfWasteWidth;
    const storageX = handlingX + handlingWidth;
    const disposalX = storageX + storageWidth;
    const adequateYX = disposalX + disposalWidth;
    const adequateNX = adequateYX + adequateYWidth;
    const previousRecordX = adequateNX + adequateNWidth;
    const q2GeneratedX = previousRecordX + previousRecordWidth;
    const totalX2 = q2GeneratedX + q2GeneratedWidth;

    // Header heights
    const headerRow1Height = 17;
    const headerRow2Height = 22;
    const totalHeaderHeight = headerRow1Height + headerRow2Height;

    const minRowHeight = 16;
    const rowPadding = 6;
    let tableBottomLimit = bottomLimit;

    const recalcBottomLimit = () =>
      doc.page.height - (doc.page.margins.bottom || 50) - 30;

    const drawRowTopBorder = (rowY: number) => {
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, rowY)
        .lineTo(left + tableWidth, rowY)
        .stroke();
    };

    const drawCheckMark = (
      cellX: number,
      cellWidth: number,
      rowY: number,
      cellHeight: number,
    ) => {
      const checkmarkSize = 4;
      const centerX = cellX + cellWidth / 2;
      const centerY = rowY + cellHeight / 2;

      doc
        .save()
        .lineWidth(1.2)
        .moveTo(centerX - checkmarkSize, centerY)
        .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
        .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
        .stroke()
        .restore();
    };

    if (y + totalHeaderHeight + minRowHeight > tableBottomLimit) {
      doc.addPage();
      tableBottomLimit = recalcBottomLimit();
      y = doc.page.margins.top || 50;
    }

    // Draw header
    const drawHeader = (startY: number): number => {
      doc
        .font('Helvetica-Bold')
        .fontSize(11)
        .strokeColor('#000000')
        .lineWidth(0.5);

      // Outer borders
      doc
        .moveTo(left, startY)
        .lineTo(left + tableWidth, startY)
        .stroke();

      // Row 1: Type of Waste | ECC/EPEP Commitments | Adequate | Previous Record | Q2 2025 Generated HW | Total
      // Type of Waste (merged 3 rows)
      doc
        .moveTo(typeOfWasteX, startY)
        .lineTo(typeOfWasteX, startY + totalHeaderHeight)
        .stroke();
      doc
        .moveTo(handlingX, startY)
        .lineTo(handlingX, startY + totalHeaderHeight)
        .stroke();

      const typeText = 'Type of Waste';
      const typeTextHeight = doc.heightOfString(typeText, {
        width: typeOfWasteWidth - 4,
        align: 'center',
      });
      const typeCenteredY = startY + (totalHeaderHeight - typeTextHeight) / 2;
      doc.text(typeText, typeOfWasteX + 2, typeCenteredY, {
        width: typeOfWasteWidth - 4,
        align: 'center',
      });

      // ECC/EPEP Commitments (spans Handling, Storage, Disposal)
      const eccWidth = handlingWidth + storageWidth + disposalWidth;
      doc
        .moveTo(handlingX + eccWidth, startY)
        .lineTo(handlingX + eccWidth, startY + headerRow1Height)
        .stroke();
      doc.text('ECC/ EPEP Commitments', handlingX + 2, startY + 5, {
        width: eccWidth - 4,
        align: 'center',
      });

      // Adequate (spans Y, N - merged rows 1 and 2)
      const adequateWidth = adequateYWidth + adequateNWidth;
      doc
        .moveTo(adequateYX, startY)
        .lineTo(adequateYX, startY + headerRow1Height)
        .stroke();
      doc
        .moveTo(adequateYX + adequateWidth, startY)
        .lineTo(adequateYX + adequateWidth, startY + headerRow1Height)
        .stroke();

      const adequateText = 'Adequate';
      const adequateTextHeight = doc.heightOfString(adequateText, {
        width: adequateWidth - 4,
        align: 'center',
      });
      const adequateCenteredY =
        startY + (headerRow1Height - adequateTextHeight + 4) / 2;
      doc.text(adequateText, adequateYX + 2, adequateCenteredY, {
        width: adequateWidth - 4,
        align: 'center',
      });

      // Previous Record (merged 3 rows)
      doc
        .moveTo(previousRecordX, startY)
        .lineTo(previousRecordX, startY + totalHeaderHeight)
        .stroke();
      doc
        .moveTo(q2GeneratedX, startY)
        .lineTo(q2GeneratedX, startY + totalHeaderHeight)
        .stroke();

      const prevText = 'Previous Record';
      const prevTextHeight = doc.heightOfString(prevText, {
        width: previousRecordWidth - 4,
        align: 'center',
      });
      const prevCenteredY = startY + (totalHeaderHeight - prevTextHeight) / 2;
      doc.text(prevText, previousRecordX + 2, prevCenteredY, {
        width: previousRecordWidth - 4,
        align: 'center',
      });

      // Q2 2025 Generated HW (merged 3 rows)
      doc
        .moveTo(totalX2, startY)
        .lineTo(totalX2, startY + totalHeaderHeight)
        .stroke();

      const q2Text = 'Q2 2025 Generated HW';
      const q2TextHeight = doc.heightOfString(q2Text, {
        width: q2GeneratedWidth - 4,
        align: 'center',
      });
      const q2CenteredY = startY + (totalHeaderHeight - q2TextHeight + 4) / 2;
      doc.text(q2Text, q2GeneratedX + 2, q2CenteredY, {
        width: q2GeneratedWidth - 4,
        align: 'center',
      });

      // Total (merged 3 rows)
      doc
        .moveTo(totalX2 + totalWidth2, startY)
        .lineTo(totalX2 + totalWidth2, startY + totalHeaderHeight)
        .stroke();

      const totalText = 'Total';
      const totalTextHeight = doc.heightOfString(totalText, {
        width: totalWidth2 - 4,
        align: 'center',
      });
      const totalCenteredY = startY + (totalHeaderHeight - totalTextHeight) / 2;
      doc.text(totalText, totalX2 + 2, totalCenteredY, {
        width: totalWidth2 - 4,
        align: 'center',
      });

      const row1BottomY = startY + headerRow1Height;
      doc
        .moveTo(handlingX, row1BottomY)
        .lineTo(adequateYX, row1BottomY)
        .stroke();
      doc
        .moveTo(adequateYX, row1BottomY)
        .lineTo(previousRecordX, row1BottomY)
        .stroke();

      // Row 2: Handling | Storage | Disposal | Y | N
      const row2Y = startY + headerRow1Height;

      doc
        .moveTo(storageX, row2Y)
        .lineTo(storageX, row2Y + headerRow2Height)
        .stroke()
        .fontSize(10);
      doc.text('Handling', handlingX + 2, row2Y + 5, {
        width: handlingWidth - 4,
        align: 'center',
      });

      doc
        .moveTo(disposalX, row2Y)
        .lineTo(disposalX, row2Y + headerRow2Height)
        .stroke();
      doc.text('Storage', storageX + 2, row2Y + 5, {
        width: storageWidth - 4,
        align: 'center',
      });

      doc.text('Disposal', disposalX + 2, row2Y + 5, {
        width: disposalWidth - 4,
        align: 'center',
      });

      doc
        .moveTo(adequateYX, row2Y)
        .lineTo(adequateYX, row2Y + headerRow2Height)
        .stroke();
      doc
        .moveTo(adequateNX, row2Y)
        .lineTo(adequateNX, row2Y + headerRow2Height)
        .stroke();
      doc.text('Y', adequateYX + 2, row2Y + 5, {
        width: adequateYWidth - 4,
        align: 'center',
      });

      doc.text('N', adequateNX + 2, row2Y + 5, {
        width: adequateNWidth - 4,
        align: 'center',
      });

      const row2BottomY = row2Y + headerRow2Height;
      doc
        .moveTo(left, row2BottomY)
        .lineTo(left + tableWidth, row2BottomY)
        .stroke();

      return startY + totalHeaderHeight;
    };

    y = drawHeader(y);

    // Data rows
    doc.font('Helvetica').fontSize(9);

    for (const item of items) {
      const typeOfWaste = item.typeOfWaste || '';
      const handling = item.eccEpepCommitments?.handling || '-';
      const storage = item.eccEpepCommitments?.storage || '-';
      const disposalValue = item.eccEpepCommitments?.disposal;
      const adequateYValue = item.adequate?.y ?? false;
      const adequateNValue = item.adequate?.n ?? false;

      const disposalTextForHeight =
        disposalValue === undefined ? '-' : disposalValue ? 'Yes' : 'No';
      const adequateYTextForHeight = adequateYValue ? 'Yes' : '';
      const adequateNTextForHeight = adequateNValue ? 'Yes' : '';

      // Format the record values (handle both string and object)
      const formatValue = (
        val: string | Record<string, number> | undefined,
      ): string => {
        if (!val) return '-';
        if (typeof val === 'string') return val;
        // If object, format as "KEY: value, KEY: value"
        return Object.entries(val)
          .map(([k, v]) => `${k}: ${v}`)
          .join(', ');
      };

      const previousRecord = formatValue(item.previousRecord);
      const q2Generated = formatValue(item.q2_2025_Generated_HW);
      const totalValue = formatValue(item.total);

      // Calculate row height based on all columns
      doc.font('Helvetica').fontSize(9);

      const typeTextHeight = doc.heightOfString(typeOfWaste, {
        width: typeOfWasteWidth - 4,
      });
      const handlingTextHeight = doc.heightOfString(handling, {
        width: handlingWidth - 4,
      });
      const storageTextHeight = doc.heightOfString(storage, {
        width: storageWidth - 4,
      });
      const disposalTextHeight = doc.heightOfString(disposalTextForHeight, {
        width: disposalWidth - 4,
      });
      const adequateYTextHeight = doc.heightOfString(adequateYTextForHeight, {
        width: adequateYWidth - 4,
      });
      const adequateNTextHeight = doc.heightOfString(adequateNTextForHeight, {
        width: adequateNWidth - 4,
      });
      const previousTextHeight = doc.heightOfString(previousRecord, {
        width: previousRecordWidth - 4,
      });
      const q2TextHeight = doc.heightOfString(q2Generated, {
        width: q2GeneratedWidth - 4,
      });
      const totalTextHeight = doc.heightOfString(totalValue, {
        width: totalWidth2 - 4,
      });

      const maxTextHeight = Math.max(
        typeTextHeight,
        handlingTextHeight,
        storageTextHeight,
        disposalTextHeight,
        adequateYTextHeight,
        adequateNTextHeight,
        previousTextHeight,
        q2TextHeight,
        totalTextHeight,
      );

      const rowHeight = Math.max(minRowHeight, maxTextHeight + rowPadding);

      if (y + rowHeight > tableBottomLimit) {
        doc.addPage();
        tableBottomLimit = recalcBottomLimit();
        y = doc.page.margins.top || 50;
        drawRowTopBorder(y);
        doc.font('Helvetica').fontSize(9);
      }

      // Draw borders
      doc.strokeColor('#000000').lineWidth(0.5);

      doc
        .moveTo(typeOfWasteX, y)
        .lineTo(typeOfWasteX, y + rowHeight)
        .stroke();
      doc
        .moveTo(handlingX, y)
        .lineTo(handlingX, y + rowHeight)
        .stroke();
      doc
        .moveTo(storageX, y)
        .lineTo(storageX, y + rowHeight)
        .stroke();
      doc
        .moveTo(disposalX, y)
        .lineTo(disposalX, y + rowHeight)
        .stroke();
      doc
        .moveTo(adequateYX, y)
        .lineTo(adequateYX, y + rowHeight)
        .stroke();
      doc
        .moveTo(adequateNX, y)
        .lineTo(adequateNX, y + rowHeight)
        .stroke();
      doc
        .moveTo(previousRecordX, y)
        .lineTo(previousRecordX, y + rowHeight)
        .stroke();
      doc
        .moveTo(q2GeneratedX, y)
        .lineTo(q2GeneratedX, y + rowHeight)
        .stroke();
      doc
        .moveTo(totalX2, y)
        .lineTo(totalX2, y + rowHeight)
        .stroke();
      doc
        .moveTo(totalX2 + totalWidth2, y)
        .lineTo(totalX2 + totalWidth2, y + rowHeight)
        .stroke();

      const typeTextY = y + (rowHeight - typeTextHeight) / 2;
      doc.text(typeOfWaste, typeOfWasteX + 2, typeTextY, {
        width: typeOfWasteWidth - 4,
        align: 'center',
      });

      const handlingTextY = y + (rowHeight - handlingTextHeight) / 2;
      doc.text(handling, handlingX + 2, handlingTextY, {
        width: handlingWidth - 4,
        align: 'center',
      });

      const storageTextY = y + (rowHeight - storageTextHeight) / 2;
      doc.text(storage, storageX + 2, storageTextY, {
        width: storageWidth - 4,
        align: 'center',
      });

      if (disposalValue === undefined) {
        const disposalTextY = y + (rowHeight - disposalTextHeight) / 2;
        doc.text('-', disposalX + 2, disposalTextY, {
          width: disposalWidth - 4,
          align: 'center',
        });
      } else if (disposalValue) {
        drawCheckMark(disposalX, disposalWidth, y, rowHeight);
      } else {
        const disposalTextY = y + (rowHeight - disposalTextHeight) / 2;
        doc.text('No', disposalX + 2, disposalTextY, {
          width: disposalWidth - 4,
          align: 'center',
        });
      }

      if (adequateYValue) {
        drawCheckMark(adequateYX, adequateYWidth, y, rowHeight);
      }

      if (adequateNValue) {
        drawCheckMark(adequateNX, adequateNWidth, y, rowHeight);
      }

      const previousTextY = y + (rowHeight - previousTextHeight) / 2;
      doc.text(previousRecord, previousRecordX + 2, previousTextY, {
        width: previousRecordWidth - 4,
        align: 'center',
      });

      const q2TextY = y + (rowHeight - q2TextHeight) / 2;
      doc.text(q2Generated, q2GeneratedX + 2, q2TextY, {
        width: q2GeneratedWidth - 4,
        align: 'center',
      });

      const totalTextY = y + (rowHeight - totalTextHeight) / 2;
      doc.text(totalValue, totalX2 + 2, totalTextY, {
        width: totalWidth2 - 4,
        align: 'center',
      });

      // Bottom border
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      y += rowHeight;
    }

    doc.moveDown(1);
    y = doc.y;
  };

  // Render quarry table if it's an array
  if (data.quarry && Array.isArray(data.quarry) && data.quarry.length > 0) {
    renderWasteTable('Quarry', data.quarry);
  }

  // Render plant - can be text or table
  if (data.plant) {
    if (typeof data.plant === 'string') {
      // Display as text
      const textIndent = 60;
      doc.font('Helvetica-Bold').fontSize(11);
      doc.text('Plant: ', left + textIndent, doc.y, {
        continued: true,
        lineBreak: false,
      });
      doc.font('Helvetica').fontSize(11);
      doc.text(data.plant);
      doc.moveDown(2);
    } else if (Array.isArray(data.plant) && data.plant.length > 0) {
      renderWasteTable('Plant', data.plant);
    }
  }

  // Render port - can be text or table
  if (data.port) {
    if (typeof data.port === 'string') {
      // Display as text
      const textIndent = 60;
      doc.font('Helvetica-Bold').fontSize(11);
      doc.text('Port: ', left + textIndent, doc.y, {
        continued: true,
        lineBreak: false,
      });
      doc.font('Helvetica').fontSize(11);
      doc.text(data.port);
      doc.moveDown(2);
    } else if (Array.isArray(data.port) && data.port.length > 0) {
      renderWasteTable('Port', data.port);
    }
  }

  doc.y = y;
  doc.moveDown(0.5);
}
