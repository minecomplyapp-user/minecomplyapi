import type { CMVRGeneralInfo } from './cmvr-pdf-generator.service';
import {
  formatDate,
  formatMaybeDateOrRange,
  getOrdinalSuffix,
  formatQuarterWithSuperscript,
} from './cmvr-pdf.helpers';

/**
 * Rendering helper functions for CMVR PDF generation
 * This file contains functions that directly manipulate the PDFDocument for rendering tables and text
 */

/**
 * Add footer to the PDF document
 */
export function addFooter(doc: PDFKit.PDFDocument): void {
  const text = 'Generated by MineComply';
  const y = doc.page.height - (doc.page.margins.bottom || 50) + 20;
  doc
    .font('Helvetica-Oblique')
    .fontSize(8)
    .fillColor('#666666')
    .text(text, doc.page.margins.left || 50, y, {
      width:
        doc.page.width -
        (doc.page.margins.left || 50) -
        (doc.page.margins.right || 50),
      align: 'center',
    })
    .fillColor('#000000');
}

/**
 * Draw a two-column key/value table WITHOUT a header row
 */
export function drawKeyValueTableNoHeader(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const colWidths = [tableWidth * 0.5, tableWidth * 0.5];
  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the table (since there's no header)
  doc
    .moveTo(left, y)
    .lineTo(left + tableWidth, y)
    .stroke();

  for (const [key, value] of rows) {
    const textHeightLeft = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const textHeightRight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const rowHeight =
      Math.max(rowMinHeight, textHeightLeft, textHeightRight) + 3; // padding

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: left/right edges, internal divider, bottom line
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Column divider
    doc
      .moveTo(left + colWidths[0], y)
      .lineTo(left + colWidths[0], y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Cell text (centered vertically)
    const keyTextHeight = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const valueTextHeight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const keyTextY = y + (rowHeight - keyTextHeight) / 2;
    const valueTextY = y + (rowHeight - valueTextHeight) / 2;

    doc.font('Helvetica').text(key, left + 5, keyTextY, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    doc
      .font('Helvetica-Bold')
      .text(value, left + colWidths[0] + 5, valueTextY, {
        width: colWidths[1] - 10,
        align: 'center',
      });

    y += rowHeight;
  }
  doc.moveDown(1);
}

/**
 * Draw a key/value table with label and colon columns (no header row)
 */
export function drawKeyValueTableWithColon(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
  suppressBottomSpacing?: boolean,
  customLabelColWidth?: number,
  customValueColWidth?: number,
  connectPrevious?: boolean,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Use custom widths if provided, otherwise use same dimensions as ECC/ISAG/MPP tables
  const labelColWidth = customLabelColWidth ?? 70;
  const colonColWidth = 15;
  const valueColWidth =
    customValueColWidth ?? tableWidth - labelColWidth - colonColWidth;

  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the entire table (skip if connecting to previous section)
  if (!connectPrevious) {
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();
  }

  for (const [key, value] of rows) {
    // Handle newlines in both key and value
    // Replace literal \n strings with actual newline characters
    // Also ensure existing newlines are preserved
    const processedKey = key.replace(/\\n/g, '\n');
    const processedValue = value.replace(/\\n/g, '\n');

    // Set font before measuring to ensure accurate height calculation
    doc.font('Helvetica-Bold').fontSize(11);
    const labelHeight = doc.heightOfString(processedKey, {
      width: labelColWidth - 10,
      align: 'left',
    });

    doc.font('Helvetica').fontSize(11);
    const valueHeight = doc.heightOfString(processedValue, {
      width: valueColWidth - 10,
      align: 'center',
    });

    const rowHeight = Math.max(rowMinHeight, labelHeight, valueHeight) + 8;

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: outer edges and dividers
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Divider between label and colon
    doc
      .moveTo(left + labelColWidth, y)
      .lineTo(left + labelColWidth, y + rowHeight)
      .stroke();
    // Divider between colon and value
    doc
      .moveTo(left + labelColWidth + colonColWidth, y)
      .lineTo(left + labelColWidth + colonColWidth, y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Draw label text (left-aligned, vertically centered)
    const labelTextY = y + (rowHeight - labelHeight) / 2;
    doc.font('Helvetica-Bold').text(processedKey, left + 5, labelTextY, {
      width: labelColWidth - 10,
      align: 'left',
    });

    // Draw colon (centered horizontally and vertically)
    const colonY = y + rowHeight / 2 - 5;
    doc.font('Helvetica-Bold').text(':', left + labelColWidth, colonY, {
      width: colonColWidth,
      align: 'center',
    });

    // Draw value text (center-aligned, vertically centered)
    const valueTextY = y + (rowHeight - valueHeight) / 2;
    doc
      .font('Helvetica')
      .text(
        processedValue,
        left + labelColWidth + colonColWidth + 5,
        valueTextY,
        {
          width: valueColWidth - 10,
          align: 'center',
        },
      );

    y += rowHeight;
  }

  // Update document cursor to the end of the table
  doc.y = y;

  if (!suppressBottomSpacing) {
    doc.moveDown(1);
  }
}

/**
 * Draw a table with optional merged label column
 */
export function drawTable(
  doc: PDFKit.PDFDocument,
  opts: {
    headers: string[];
    rows: string[][];
    labelColumn?: string;
    columnWidths?: number[]; // Optional: array of percentages (0-1) for each column
    connectPrevious?: boolean; // If true, visually connect this table to the previous one on the same page
    suppressBottomSpacing?: boolean; // If true, don't add extra spacing after the table
    suppressBottomBorder?: boolean; // If true, only draw bottom border under label area (another section follows)
  },
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // If labelColumn is provided, reserve space for label column + colon column on the left
  const labelColWidth = opts.labelColumn ? 70 : 0;
  const colonColWidth = opts.labelColumn ? 15 : 0;
  const dataTableWidth = tableWidth - labelColWidth - colonColWidth;

  // Calculate column widths - either custom or equal distribution
  let colWidths: number[];
  if (opts.columnWidths && opts.columnWidths.length === opts.headers.length) {
    // Use custom widths (percentages that should sum to 1.0)
    colWidths = opts.columnWidths.map((pct) => dataTableWidth * pct);
  } else {
    // Equal distribution
    const colWidth = dataTableWidth / opts.headers.length;
    colWidths = Array(opts.headers.length).fill(colWidth) as number[];
  }

  // Compute dynamic header height based on header text wrapping
  const rowMinHeight = 14;
  // Ensure header font is set before measuring
  doc.font('Helvetica-Bold').fontSize(11);
  const headerTextHeights = opts.headers.map((h, idx) =>
    doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    }),
  );
  const headerPadding = 10; // vertical padding within header
  const headerHeight = Math.max(25, ...headerTextHeights) + headerPadding;
  let y = doc.y;

  // Pre-calculate all row heights (use center align to match final rendering)
  const rowHeights: number[] = [];
  for (const row of opts.rows) {
    const heights = row.map((txt, idx) =>
      doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      }),
    );
    rowHeights.push(Math.max(rowMinHeight, ...heights) + 3);
  }

  // Determine if we should actually connect on this page (only if not at top of a new page)
  const topMargin = doc.page.margins.top || 50;
  const connectPrevHere = !!(opts.connectPrevious && doc.y > topMargin + 2);
  // Track whether to draw the section's top line (skip if connected to previous on same page)
  let shouldDrawSectionTop = !connectPrevHere;

  // Helper function to draw label and colon columns for a section
  const drawLabelSection = (
    startY: number,
    sectionHeight: number,
    drawTop: boolean,
    drawBottom: boolean,
  ) => {
    if (!opts.labelColumn) return;

    // Draw label column vertical edge (left outer edge)
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, startY)
      .lineTo(left, startY + sectionHeight)
      .stroke();

    // Draw top horizontal line spanning label + colon + data for this section (optional)
    if (drawTop) {
      doc
        .moveTo(left, startY)
        .lineTo(left + tableWidth, startY)
        .stroke();
    }

    // Bottom border handling (similar to fund section logic)
    if (drawBottom) {
      // Draw full width bottom border
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(left + tableWidth, startY + sectionHeight)
        .stroke();
    } else {
      // Only draw under label+colon area when another section follows
      const colonRight = left + labelColWidth + colonColWidth;
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(colonRight, startY + sectionHeight)
        .stroke();
    }

    // Vertically center the label text
    const labelY = startY + sectionHeight / 2 - 5;
    doc
      .font('Helvetica-Bold')
      .fontSize(12)
      .text(opts.labelColumn.toUpperCase(), left + 5, labelY, {
        width: labelColWidth - 10,
        align: 'center',
      });

    // Draw colon column: only the divider between label and colon (no right edge to avoid double with dataLeft)
    const colonLeft = left + labelColWidth;
    doc
      .moveTo(colonLeft, startY)
      .lineTo(colonLeft, startY + sectionHeight)
      .stroke();

    // Vertically center the colon
    const colonY = startY + sectionHeight / 2 - 5;
    doc.font('Helvetica-Bold').fontSize(12).text(':', colonLeft, colonY, {
      width: colonColWidth,
      align: 'center',
    });
  };

  // Offset data columns to the right if label column exists
  const dataLeft = left + labelColWidth + colonColWidth;

  // Helper to get X position for a column (cumulative width up to that column)
  const getColX = (colIndex: number): number => {
    return (
      dataLeft + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0)
    );
  };

  // Track section start for merged label column
  let sectionStartY = y;
  let sectionRowsHeight = headerHeight; // Start with header height

  // Header for data columns - draw borders without double lines
  doc.font('Helvetica-Bold').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Header outer edges
  doc
    .moveTo(dataLeft, y)
    .lineTo(dataLeft, y + headerHeight)
    .stroke(); // Left
  doc
    .moveTo(dataLeft + dataTableWidth, y)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Right
  // Top border is drawn by drawLabelSection to avoid double lines; skip drawing top here
  doc
    .moveTo(dataLeft, y + headerHeight)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Bottom

  // Header column dividers
  for (let i = 1; i < opts.headers.length; i++) {
    const colX = getColX(i);
    doc
      .moveTo(colX, y)
      .lineTo(colX, y + headerHeight)
      .stroke();
  }

  opts.headers.forEach((h, idx) => {
    const colX = getColX(idx);
    const textHeight = doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
    const textY = y + (headerHeight - textHeight) / 2; // vertical center
    doc.text(h, colX + 5, textY, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
  });
  y += headerHeight;
  doc.font('Helvetica').fontSize(11);

  opts.rows.forEach((row, rowIndex) => {
    const rowHeight = rowHeights[rowIndex];

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      // Draw label section for rows on current page before page break (not final, so respect suppressBottomBorder)
      drawLabelSection(
        sectionStartY,
        sectionRowsHeight,
        shouldDrawSectionTop,
        !opts.suppressBottomBorder, // drawBottom: false if another section follows
      );
      // After first segment, always draw top for subsequent segments
      shouldDrawSectionTop = true;

      doc.addPage();
      y = doc.page.margins.top || 50;

      // Reset section tracking for new page
      sectionStartY = y;
      sectionRowsHeight = headerHeight;

      // redraw header
      doc
        .font('Helvetica-Bold')
        .fontSize(11)
        .strokeColor('#000000')
        .lineWidth(0.5);

      // Header outer edges
      doc
        .moveTo(dataLeft, y)
        .lineTo(dataLeft, y + headerHeight)
        .stroke(); // Left
      doc
        .moveTo(dataLeft + dataTableWidth, y)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Right
      // Top border is handled by drawLabelSection later to avoid double lines; skip drawing top here
      doc
        .moveTo(dataLeft, y + headerHeight)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Bottom

      // Header column dividers
      for (let i = 1; i < opts.headers.length; i++) {
        const colX = getColX(i);
        doc
          .moveTo(colX, y)
          .lineTo(colX, y + headerHeight)
          .stroke();
      }
      opts.headers.forEach((h, idx) => {
        const colX = getColX(idx);
        const textHeight = doc.heightOfString(h, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
        const textY = y + (headerHeight - textHeight) / 2; // vertical center
        doc.text(h, colX + 5, textY, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
      });
      y += headerHeight;
      doc.font('Helvetica').fontSize(11);
    }

    // Row borders (no double lines): draw left/right edges and the bottom line only
    // Left outer edge
    doc
      .moveTo(dataLeft, y)
      .lineTo(dataLeft, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(dataLeft + dataTableWidth, y)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();
    // Internal column dividers
    for (let i = 1; i < opts.headers.length; i++) {
      const colX = getColX(i);
      doc
        .moveTo(colX, y)
        .lineTo(colX, y + rowHeight)
        .stroke();
    }
    // Bottom horizontal line only under data area (preserve merged label/colon appearance)
    doc
      .moveTo(dataLeft, y + rowHeight)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();

    // Row cells (centered horizontally and vertically)
    row.forEach((txt, idx) => {
      const colX = getColX(idx);
      const textHeight = doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
      const textY = y + (rowHeight - textHeight) / 2; // vertical center
      doc.text(txt, colX + 5, textY, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
    });

    y += rowHeight;
    sectionRowsHeight += rowHeight; // Accumulate height for label section
  });

  // Draw final label section for last page (this is the final segment)
  drawLabelSection(
    sectionStartY,
    sectionRowsHeight,
    shouldDrawSectionTop,
    !opts.suppressBottomBorder, // drawBottom: false if another section follows
  );

  // Update document cursor position to end of table
  doc.y = y;
  if (!opts.suppressBottomSpacing) {
    doc.moveDown(0.5);
  }
}

/**
 * Draw the summary text section with formatted title and company info
 */
export function drawSummaryText(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const width = right - left;
  const boxPct = 0.8;
  const boxPctLocation = 0.9;
  const y = width * boxPctLocation;
  const w = width * boxPct;
  const x = left + (width - w) / 2;
  const z = left + (width - y) / 2;

  doc.moveDown(0.8);

  // Title: "3rd QUARTER CY 2025 MMT COMPLIANCE MONITORING AND VALIDATION REPORT"
  doc.font('Helvetica-Bold').fontSize(11);

  const titleParts: string[] = [];
  if (gi.quarter) {
    // Format quarter with superscript ordinal (e.g., "3RD" becomes "3" with superscript "RD")
    const quarterFormatted = formatQuarterWithSuperscript(gi.quarter);
    titleParts.push(quarterFormatted);
  }
  if (gi.year) {
    titleParts.push(`CY ${gi.year}`);
  }
  titleParts.push('MMT COMPLIANCE MONITORING');

  // First line of title
  const titleLine1 = titleParts.join(' ');

  // If quarter has superscript, we need to manually draw it
  if (gi.quarter) {
    const yPos = doc.y;
    const quarterNum = gi.quarter.replace(/\D/g, ''); // Extract number
    const ordinal = getOrdinalSuffix(parseInt(quarterNum, 10)); // Get suffix

    // Build the text parts
    const afterQuarter = ' QUARTER';
    const restOfTitle = titleParts.slice(1).join(' ');

    // Measure to center the whole line (approximate with regular font for ordinal)
    const fullTextApprox = `${quarterNum}${ordinal}${afterQuarter} ${restOfTitle}`;
    const textWidth = doc.widthOfString(fullTextApprox);
    let xPos = left + (width - textWidth) / 2;

    // Draw quarter number
    doc.fontSize(11);
    doc.text(quarterNum, xPos, yPos, { continued: false });
    xPos += doc.widthOfString(quarterNum);

    // Draw ordinal as superscript (smaller font, raised) - no space before it
    doc.fontSize(7);
    const ordinalWidth = doc.widthOfString(ordinal);
    doc.text(ordinal, xPos, yPos - 1.5, { continued: false });
    xPos += ordinalWidth;

    // Draw rest of line
    doc.fontSize(11);
    doc.text(`${afterQuarter} ${restOfTitle}`, xPos, yPos, {
      continued: false,
    });
    doc.moveDown(0.5);
  } else {
    doc.text(titleLine1, left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  // Second line
  doc.text('AND VALIDATION REPORT', left, doc.y, {
    width: width,
    align: 'center',
  });
  doc.moveDown(2);

  // Company name centered
  if (gi.projectCurrentName) {
    doc.text(gi.projectCurrentName.toUpperCase(), left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  doc.font('Helvetica');

  doc.text(
    `(This CMVR covers the ISAG Permit of ONRI and Fourteen (14) ISAG Permits under Supply Agreement with ONRI)`,
    x,
    doc.y,
    {
      width: w,
      align: 'center',
    },
  );

  doc.moveDown(1).font('Helvetica-Bold');

  // Display location field if it's a string, otherwise use mailing address
  if (typeof gi.location === 'string') {
    doc.text(gi.location.toUpperCase(), z, doc.y, {
      width: y,
      align: 'center',
    });
  }

  doc.moveDown(1);
}

/**
 * Add general info key-value pairs (compliance dates and summary)
 */
export function addGeneralInfoKeyValues(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  // Render summary as formatted text (not a table) and compliance dates as a no-header table

  const complianceRows: Array<[string, string]> = [];

  if (gi.dateOfComplianceMonitoringAndValidation) {
    complianceRows.push([
      'Date of Compliance Monitoring and Validation',
      formatDate(gi.dateOfComplianceMonitoringAndValidation),
    ]);
  }
  if (gi.monitoringPeriodCovered) {
    complianceRows.push([
      'Monitoring Period Covered',
      formatMaybeDateOrRange(gi.monitoringPeriodCovered),
    ]);
  }
  if (gi.dateOfCmrSubmission) {
    complianceRows.push([
      'Date of CMR Submission',
      formatDate(gi.dateOfCmrSubmission),
    ]);
  }

  // Render summary section as formatted text (no "SUMMARY" title)
  drawSummaryText(doc, gi);

  if (complianceRows.length > 0) {
    // Render the three compliance-related rows as a separate table without a header
    drawKeyValueTableNoHeader(doc, complianceRows);
  }
}
