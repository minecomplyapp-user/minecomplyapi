import type { CMVRGeneralInfo } from './cmvr-pdf-generator.service';
import {
  formatDate,
  formatMaybeDateOrRange,
  getOrdinalSuffix,
  formatQuarterWithSuperscript,
} from './cmvr-pdf.helpers';

/**
 * Rendering helper functions for CMVR PDF generation
 * This file contains functions that directly manipulate the PDFDocument for rendering tables and text
 */

/**
 * Add footer to the PDF document
 */
export function addFooter(doc: PDFKit.PDFDocument): void {
  const text = 'Generated by MineComply';
  const y = doc.page.height - (doc.page.margins.bottom || 50) + 20;
  doc
    .font('Helvetica-Oblique')
    .fontSize(8)
    .fillColor('#666666')
    .text(text, doc.page.margins.left || 50, y, {
      width:
        doc.page.width -
        (doc.page.margins.left || 50) -
        (doc.page.margins.right || 50),
      align: 'center',
    })
    .fillColor('#000000');
}

/**
 * Draw a two-column key/value table WITHOUT a header row
 */
export function drawKeyValueTableNoHeader(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const colWidths = [tableWidth * 0.5, tableWidth * 0.5];
  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the table (since there's no header)
  doc
    .moveTo(left, y)
    .lineTo(left + tableWidth, y)
    .stroke();

  for (const [key, value] of rows) {
    const textHeightLeft = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const textHeightRight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const rowHeight =
      Math.max(rowMinHeight, textHeightLeft, textHeightRight) + 3; // padding

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: left/right edges, internal divider, bottom line
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Column divider
    doc
      .moveTo(left + colWidths[0], y)
      .lineTo(left + colWidths[0], y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Cell text (centered vertically)
    const keyTextHeight = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const valueTextHeight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const keyTextY = y + (rowHeight - keyTextHeight) / 2;
    const valueTextY = y + (rowHeight - valueTextHeight) / 2;

    doc.font('Helvetica').text(key, left + 5, keyTextY, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    doc
      .font('Helvetica-Bold')
      .text(value, left + colWidths[0] + 5, valueTextY, {
        width: colWidths[1] - 10,
        align: 'center',
      });

    y += rowHeight;
  }
  doc.moveDown(1);
}

/**
 * Draw a key/value table with label and colon columns (no header row)
 */
export function drawKeyValueTableWithColon(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
  suppressBottomSpacing?: boolean,
  customLabelColWidth?: number,
  customValueColWidth?: number,
  connectPrevious?: boolean,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Use custom widths if provided, otherwise use same dimensions as ECC/ISAG/MPP tables
  const labelColWidth = customLabelColWidth ?? 70;
  const colonColWidth = 15;
  const valueColWidth =
    customValueColWidth ?? tableWidth - labelColWidth - colonColWidth;

  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the entire table (skip if connecting to previous section)
  if (!connectPrevious) {
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();
  }

  for (const [key, value] of rows) {
    // Handle newlines in both key and value
    // Replace literal \n strings with actual newline characters
    // Also ensure existing newlines are preserved
    const processedKey = key.replace(/\\n/g, '\n');
    const processedValue = value.replace(/\\n/g, '\n');

    // Set font before measuring to ensure accurate height calculation
    doc.font('Helvetica-Bold').fontSize(11);
    const labelHeight = doc.heightOfString(processedKey, {
      width: labelColWidth - 10,
      align: 'left',
    });

    doc.font('Helvetica').fontSize(11);
    const valueHeight = doc.heightOfString(processedValue, {
      width: valueColWidth - 10,
      align: 'center',
    });

    const rowHeight = Math.max(rowMinHeight, labelHeight, valueHeight) + 8;

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: outer edges and dividers
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Divider between label and colon
    doc
      .moveTo(left + labelColWidth, y)
      .lineTo(left + labelColWidth, y + rowHeight)
      .stroke();
    // Divider between colon and value
    doc
      .moveTo(left + labelColWidth + colonColWidth, y)
      .lineTo(left + labelColWidth + colonColWidth, y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Draw label text (left-aligned, vertically centered)
    const labelTextY = y + (rowHeight - labelHeight) / 2;
    doc.font('Helvetica-Bold').text(processedKey, left + 5, labelTextY, {
      width: labelColWidth - 10,
      align: 'left',
    });

    // Draw colon (centered horizontally and vertically)
    const colonY = y + rowHeight / 2 - 5;
    doc.font('Helvetica-Bold').text(':', left + labelColWidth, colonY, {
      width: colonColWidth,
      align: 'center',
    });

    // Draw value text (center-aligned, vertically centered)
    const valueTextY = y + (rowHeight - valueHeight) / 2;
    doc
      .font('Helvetica')
      .text(
        processedValue,
        left + labelColWidth + colonColWidth + 5,
        valueTextY,
        {
          width: valueColWidth - 10,
          align: 'center',
        },
      );

    y += rowHeight;
  }

  // Update document cursor to the end of the table
  doc.y = y;

  if (!suppressBottomSpacing) {
    doc.moveDown(1);
  }
}

/**
 * Draw a table with optional merged label column
 */
export function drawTable(
  doc: PDFKit.PDFDocument,
  opts: {
    headers: string[];
    rows: string[][];
    labelColumn?: string;
    columnWidths?: number[]; // Optional: array of percentages (0-1) for each column
    connectPrevious?: boolean; // If true, visually connect this table to the previous one on the same page
    suppressBottomSpacing?: boolean; // If true, don't add extra spacing after the table
    suppressBottomBorder?: boolean; // If true, only draw bottom border under label area (another section follows)
  },
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // If labelColumn is provided, reserve space for label column + colon column on the left
  const labelColWidth = opts.labelColumn ? 70 : 0;
  const colonColWidth = opts.labelColumn ? 15 : 0;
  const dataTableWidth = tableWidth - labelColWidth - colonColWidth;

  // Calculate column widths - either custom or equal distribution
  let colWidths: number[];
  if (opts.columnWidths && opts.columnWidths.length === opts.headers.length) {
    // Use custom widths (percentages that should sum to 1.0)
    colWidths = opts.columnWidths.map((pct) => dataTableWidth * pct);
  } else {
    // Equal distribution
    const colWidth = dataTableWidth / opts.headers.length;
    colWidths = Array(opts.headers.length).fill(colWidth) as number[];
  }

  // Compute dynamic header height based on header text wrapping
  const rowMinHeight = 14;
  // Ensure header font is set before measuring
  doc.font('Helvetica-Bold').fontSize(11);
  const headerTextHeights = opts.headers.map((h, idx) =>
    doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    }),
  );
  const headerPadding = 10; // vertical padding within header
  const headerHeight = Math.max(25, ...headerTextHeights) + headerPadding;
  let y = doc.y;

  // Pre-calculate all row heights (use center align to match final rendering)
  const rowHeights: number[] = [];
  for (const row of opts.rows) {
    const heights = row.map((txt, idx) =>
      doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      }),
    );
    rowHeights.push(Math.max(rowMinHeight, ...heights) + 3);
  }

  // Determine if we should actually connect on this page (only if not at top of a new page)
  const topMargin = doc.page.margins.top || 50;
  const connectPrevHere = !!(opts.connectPrevious && doc.y > topMargin + 2);
  // Track whether to draw the section's top line (skip if connected to previous on same page)
  let shouldDrawSectionTop = !connectPrevHere;

  // Helper function to draw label and colon columns for a section
  const drawLabelSection = (
    startY: number,
    sectionHeight: number,
    drawTop: boolean,
    drawBottom: boolean,
  ) => {
    if (!opts.labelColumn) return;

    // Draw label column vertical edge (left outer edge)
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, startY)
      .lineTo(left, startY + sectionHeight)
      .stroke();

    // Draw top horizontal line spanning label + colon + data for this section (optional)
    if (drawTop) {
      doc
        .moveTo(left, startY)
        .lineTo(left + tableWidth, startY)
        .stroke();
    }

    // Bottom border handling (similar to fund section logic)
    if (drawBottom) {
      // Draw full width bottom border
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(left + tableWidth, startY + sectionHeight)
        .stroke();
    } else {
      // Only draw under label+colon area when another section follows
      const colonRight = left + labelColWidth + colonColWidth;
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(colonRight, startY + sectionHeight)
        .stroke();
    }

    // Vertically center the label text
    const labelY = startY + sectionHeight / 2 - 5;
    doc
      .font('Helvetica-Bold')
      .fontSize(12)
      .text(opts.labelColumn.toUpperCase(), left + 5, labelY, {
        width: labelColWidth - 10,
        align: 'center',
      });

    // Draw colon column: only the divider between label and colon (no right edge to avoid double with dataLeft)
    const colonLeft = left + labelColWidth;
    doc
      .moveTo(colonLeft, startY)
      .lineTo(colonLeft, startY + sectionHeight)
      .stroke();

    // Vertically center the colon
    const colonY = startY + sectionHeight / 2 - 5;
    doc.font('Helvetica-Bold').fontSize(12).text(':', colonLeft, colonY, {
      width: colonColWidth,
      align: 'center',
    });
  };

  // Offset data columns to the right if label column exists
  const dataLeft = left + labelColWidth + colonColWidth;

  // Helper to get X position for a column (cumulative width up to that column)
  const getColX = (colIndex: number): number => {
    return (
      dataLeft + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0)
    );
  };

  // Track section start for merged label column
  let sectionStartY = y;
  let sectionRowsHeight = headerHeight; // Start with header height

  // Header for data columns - draw borders without double lines
  doc.font('Helvetica-Bold').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Header outer edges
  doc
    .moveTo(dataLeft, y)
    .lineTo(dataLeft, y + headerHeight)
    .stroke(); // Left
  doc
    .moveTo(dataLeft + dataTableWidth, y)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Right
  // Top border is drawn by drawLabelSection to avoid double lines; skip drawing top here
  doc
    .moveTo(dataLeft, y + headerHeight)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Bottom

  // Header column dividers
  for (let i = 1; i < opts.headers.length; i++) {
    const colX = getColX(i);
    doc
      .moveTo(colX, y)
      .lineTo(colX, y + headerHeight)
      .stroke();
  }

  opts.headers.forEach((h, idx) => {
    const colX = getColX(idx);
    const textHeight = doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
    const textY = y + (headerHeight - textHeight) / 2; // vertical center
    doc.text(h, colX + 5, textY, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
  });
  y += headerHeight;
  doc.font('Helvetica').fontSize(11);

  opts.rows.forEach((row, rowIndex) => {
    const rowHeight = rowHeights[rowIndex];

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      // Draw label section for rows on current page before page break (not final, so respect suppressBottomBorder)
      drawLabelSection(
        sectionStartY,
        sectionRowsHeight,
        shouldDrawSectionTop,
        !opts.suppressBottomBorder, // drawBottom: false if another section follows
      );
      // After first segment, always draw top for subsequent segments
      shouldDrawSectionTop = true;

      doc.addPage();
      y = doc.page.margins.top || 50;

      // Reset section tracking for new page
      sectionStartY = y;
      sectionRowsHeight = headerHeight;

      // redraw header
      doc
        .font('Helvetica-Bold')
        .fontSize(11)
        .strokeColor('#000000')
        .lineWidth(0.5);

      // Header outer edges
      doc
        .moveTo(dataLeft, y)
        .lineTo(dataLeft, y + headerHeight)
        .stroke(); // Left
      doc
        .moveTo(dataLeft + dataTableWidth, y)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Right
      // Top border is handled by drawLabelSection later to avoid double lines; skip drawing top here
      doc
        .moveTo(dataLeft, y + headerHeight)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Bottom

      // Header column dividers
      for (let i = 1; i < opts.headers.length; i++) {
        const colX = getColX(i);
        doc
          .moveTo(colX, y)
          .lineTo(colX, y + headerHeight)
          .stroke();
      }
      opts.headers.forEach((h, idx) => {
        const colX = getColX(idx);
        const textHeight = doc.heightOfString(h, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
        const textY = y + (headerHeight - textHeight) / 2; // vertical center
        doc.text(h, colX + 5, textY, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
      });
      y += headerHeight;
      doc.font('Helvetica').fontSize(11);
    }

    // Row borders (no double lines): draw left/right edges and the bottom line only
    // Left outer edge
    doc
      .moveTo(dataLeft, y)
      .lineTo(dataLeft, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(dataLeft + dataTableWidth, y)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();
    // Internal column dividers
    for (let i = 1; i < opts.headers.length; i++) {
      const colX = getColX(i);
      doc
        .moveTo(colX, y)
        .lineTo(colX, y + rowHeight)
        .stroke();
    }
    // Bottom horizontal line only under data area (preserve merged label/colon appearance)
    doc
      .moveTo(dataLeft, y + rowHeight)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();

    // Row cells (centered horizontally and vertically)
    row.forEach((txt, idx) => {
      const colX = getColX(idx);
      const textHeight = doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
      const textY = y + (rowHeight - textHeight) / 2; // vertical center
      doc.text(txt, colX + 5, textY, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
    });

    y += rowHeight;
    sectionRowsHeight += rowHeight; // Accumulate height for label section
  });

  // Draw final label section for last page (this is the final segment)
  drawLabelSection(
    sectionStartY,
    sectionRowsHeight,
    shouldDrawSectionTop,
    !opts.suppressBottomBorder, // drawBottom: false if another section follows
  );

  // Update document cursor position to end of table
  doc.y = y;
  if (!opts.suppressBottomSpacing) {
    doc.moveDown(0.5);
  }
}

/**
 * Draw the summary text section with formatted title and company info
 */
export function drawSummaryText(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const width = right - left;
  const boxPct = 0.8;
  const boxPctLocation = 0.9;
  const y = width * boxPctLocation;
  const w = width * boxPct;
  const x = left + (width - w) / 2;
  const z = left + (width - y) / 2;

  doc.moveDown(0.8);

  // Title: "3rd QUARTER CY 2025 MMT COMPLIANCE MONITORING AND VALIDATION REPORT"
  doc.font('Helvetica-Bold').fontSize(11);

  const titleParts: string[] = [];
  if (gi.quarter) {
    // Format quarter with superscript ordinal (e.g., "3RD" becomes "3" with superscript "RD")
    const quarterFormatted = formatQuarterWithSuperscript(gi.quarter);
    titleParts.push(quarterFormatted);
  }
  if (gi.year) {
    titleParts.push(`CY ${gi.year}`);
  }
  titleParts.push('MMT COMPLIANCE MONITORING');

  // First line of title
  const titleLine1 = titleParts.join(' ');

  // If quarter has superscript, we need to manually draw it
  if (gi.quarter) {
    const yPos = doc.y;
    const quarterNum = gi.quarter.replace(/\D/g, ''); // Extract number
    const ordinal = getOrdinalSuffix(parseInt(quarterNum, 10)); // Get suffix

    // Build the text parts
    const afterQuarter = ' QUARTER';
    const restOfTitle = titleParts.slice(1).join(' ');

    // Measure to center the whole line (approximate with regular font for ordinal)
    const fullTextApprox = `${quarterNum}${ordinal}${afterQuarter} ${restOfTitle}`;
    const textWidth = doc.widthOfString(fullTextApprox);
    let xPos = left + (width - textWidth) / 2;

    // Draw quarter number
    doc.fontSize(11);
    doc.text(quarterNum, xPos, yPos, { continued: false });
    xPos += doc.widthOfString(quarterNum);

    // Draw ordinal as superscript (smaller font, raised) - no space before it
    doc.fontSize(7);
    const ordinalWidth = doc.widthOfString(ordinal);
    doc.text(ordinal, xPos, yPos - 1.5, { continued: false });
    xPos += ordinalWidth;

    // Draw rest of line
    doc.fontSize(11);
    doc.text(`${afterQuarter} ${restOfTitle}`, xPos, yPos, {
      continued: false,
    });
    doc.moveDown(0.5);
  } else {
    doc.text(titleLine1, left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  // Second line
  doc.text('AND VALIDATION REPORT', left, doc.y, {
    width: width,
    align: 'center',
  });
  doc.moveDown(2);

  // Company name centered
  if (gi.projectCurrentName) {
    doc.text(gi.projectCurrentName.toUpperCase(), left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  doc.font('Helvetica');

  doc.text(
    `(This CMVR covers the ISAG Permit of ONRI and Fourteen (14) ISAG Permits under Supply Agreement with ONRI)`,
    x,
    doc.y,
    {
      width: w,
      align: 'center',
    },
  );

  doc.moveDown(1).font('Helvetica-Bold');

  // Display location field if it's a string, otherwise use mailing address
  if (typeof gi.location === 'string') {
    doc.text(gi.location.toUpperCase(), z, doc.y, {
      width: y,
      align: 'center',
    });
  }

  doc.moveDown(1);
}

/**
 * Add general info key-value pairs (compliance dates and summary)
 */
export function addGeneralInfoKeyValues(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  // Render summary as formatted text (not a table) and compliance dates as a no-header table

  const complianceRows: Array<[string, string]> = [];

  if (gi.dateOfComplianceMonitoringAndValidation) {
    complianceRows.push([
      'Date of Compliance Monitoring and Validation',
      formatDate(gi.dateOfComplianceMonitoringAndValidation),
    ]);
  }
  if (gi.monitoringPeriodCovered) {
    complianceRows.push([
      'Monitoring Period Covered',
      formatMaybeDateOrRange(gi.monitoringPeriodCovered),
    ]);
  }
  if (gi.dateOfCmrSubmission) {
    complianceRows.push([
      'Date of CMR Submission',
      formatDate(gi.dateOfCmrSubmission),
    ]);
  }

  // Render summary section as formatted text (no "SUMMARY" title)
  drawSummaryText(doc, gi);

  if (complianceRows.length > 0) {
    // Render the three compliance-related rows as a separate table without a header
    drawKeyValueTableNoHeader(doc, complianceRows);
  }
}

/**
 * Draw "Executive Summary of Compliance" section with a multi-row header.
 * Header structure:
 *   Row 1: "Requirements" (merged 2 rows) | "Complied?" (spans Y+N) | "Remarks/ ECC or EPEP Condition #" (merged 2 rows)
 *   Row 2:                                 | "Y" | "N"                |
 *
 * For each requirement, mark Y or N based on boolean values.
 */
export function drawExecutiveSummaryOfCompliance(
  doc: PDFKit.PDFDocument,
  exec: NonNullable<CMVRGeneralInfo['executiveSummaryOfCompliance']>,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  const reqWidth = tableWidth * 0.57;
  const yWidth = tableWidth * 0.1;
  const nWidth = tableWidth * 0.1;
  const remarksWidth = tableWidth * 0.23;
  const compliedWidth = yWidth + nWidth; // "Complied?" spans Y + N

  const rowMinHeight = 14;
  const headerRow1Height = 20; // First header row
  const headerRow2Height = 18; // Second header row (Y/N)
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get column X positions
  const reqX = left;
  const yX = left + reqWidth;
  const nX = yX + yWidth;
  const remarksX = nX + nWidth;

  // Helper to draw the two-row header
  const drawHeader = (y: number) => {
    doc
      .strokeColor('#000000')
      .lineWidth(0.5)
      .font('Helvetica-Bold')
      .fontSize(11);

    // --- Header Row 1 ---
    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + headerRow1Height + headerRow2Height)
      .stroke();
    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + headerRow1Height + headerRow2Height)
      .stroke();

    // Vertical dividers for row 1
    doc
      .moveTo(yX, y)
      .lineTo(yX, y + headerRow1Height + headerRow2Height)
      .stroke(); // After Requirements
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + headerRow1Height + headerRow2Height)
      .stroke(); // After Complied?

    // Horizontal line after row 1
    doc
      .moveTo(yX, y + headerRow1Height)
      .lineTo(remarksX, y + headerRow1Height)
      .stroke();

    // Bottom border of header row 2
    doc
      .moveTo(left, y + headerRow1Height + headerRow2Height)
      .lineTo(left + tableWidth, y + headerRow1Height + headerRow2Height)
      .stroke();

    // --- Header Row 2 (Y/N sub-columns) ---
    doc
      .moveTo(nX, y + headerRow1Height)
      .lineTo(nX, y + headerRow1Height + headerRow2Height)
      .stroke();

    // Draw header texts
    // "Requirements" - vertically centered across both rows
    const reqText = 'Requirements';
    const reqTextHeight = doc.heightOfString(reqText, { width: reqWidth - 10 });
    const reqTextY =
      y + (headerRow1Height + headerRow2Height - reqTextHeight) / 2;
    doc.text(reqText, reqX + 5, reqTextY, {
      width: reqWidth - 10,
      align: 'center',
    });

    // "Complied?" - centered in row 1 only
    const compliedText = 'Complied?';
    const compliedTextHeight = doc.heightOfString(compliedText, {
      width: compliedWidth - 10,
    });
    const compliedTextY = y + (headerRow1Height - compliedTextHeight) / 2;
    doc.text(compliedText, yX + 5, compliedTextY, {
      width: compliedWidth - 10,
      align: 'center',
    });

    // "Remarks/ ECC or EPEP Condition #" - vertically centered across both rows
    const remarksText = 'Remarks/ ECC or EPEP Condition #';
    const remarksTextHeight = doc.heightOfString(remarksText, {
      width: remarksWidth - 10,
    });
    const remarksTextY =
      y + (headerRow1Height + headerRow2Height - remarksTextHeight) / 2;
    doc.text(remarksText, remarksX + 5, remarksTextY, {
      width: remarksWidth - 10,
      align: 'center',
    });

    // "Y" and "N" in row 2
    const yText = 'Y';
    const nText = 'N';
    const yTextY =
      y +
      headerRow1Height +
      (headerRow2Height - doc.heightOfString(yText, { width: yWidth - 10 })) /
        2;
    const nTextY =
      y +
      headerRow1Height +
      (headerRow2Height - doc.heightOfString(nText, { width: nWidth - 10 })) /
        2;
    doc.text(yText, yX + 5, yTextY, { width: yWidth - 10, align: 'center' });
    doc.text(nText, nX + 5, nTextY, { width: nWidth - 10, align: 'center' });

    return y + headerRow1Height + headerRow2Height;
  };

  // Helper to draw a data row
  const drawRow = (
    y: number,
    requirement: string,
    complied: boolean | undefined,
    remarks: string,
    options?: {
      isSubRow?: boolean;
      subRowParentHeight?: number;
      isFirstSubRow?: boolean;
      isLastSubRow?: boolean;
      isOthersMerged?: boolean; // Flag for "Others" section to always merge Y+N
      showNA?: boolean; // Flag to show "N/A" text in merged cell
    },
  ) => {
    const {
      isSubRow,
      subRowParentHeight,
      isFirstSubRow,
      isLastSubRow,
      isOthersMerged,
      showNA,
    } = options || {};

    doc.font('Helvetica').fontSize(11);
    const reqTextHeight = doc.heightOfString(requirement, {
      width: reqWidth - 10,
    });
    const remarksTextHeight = doc.heightOfString(remarks, {
      width: remarksWidth - 10,
    });
    const rowHeight =
      Math.max(rowMinHeight, reqTextHeight, remarksTextHeight) + 4;

    // Check page break
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica').fontSize(11);
    }

    // Draw row borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Right
    doc
      .moveTo(yX, y)
      .lineTo(yX, y + rowHeight)
      .stroke(); // After Requirements

    // Only draw Y/N divider if not "Others" (which always has merged Y+N)
    if (!isOthersMerged) {
      doc
        .moveTo(nX, y)
        .lineTo(nX, y + rowHeight)
        .stroke(); // Between Y and N
    }

    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + rowHeight)
      .stroke(); // After N (or after merged Y+N)
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Bottom

    // Draw texts
    const reqTextY = y + (rowHeight - reqTextHeight) / 2;
    doc.text(requirement, reqX + 5, reqTextY, {
      width: reqWidth - 10,
      align: 'left',
    });

    // If "Others" section (merged Y+N), conditionally show "N/A" or leave empty
    if (isOthersMerged) {
      const compliedMergedWidth = yWidth + nWidth;
      if (showNA) {
        const naText = 'N/A';
        const naTextHeight = doc.heightOfString(naText, {
          width: compliedMergedWidth - 10,
        });
        const naTextY = y + (rowHeight - naTextHeight) / 2;
        doc.font('Helvetica').text(naText, yX + 5, naTextY, {
          width: compliedMergedWidth - 10,
          align: 'center',
        });
      }
      // If showNA is false, the merged cell remains empty (no text drawn)
    } else {
      // Draw a checkmark manually if complied is true
      if (complied === true) {
        const checkmarkSize = 4;
        const centerX = yX + yWidth / 2;
        const centerY = y + rowHeight / 2;

        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      // Draw a checkmark in N column if complied is false
      if (complied === false) {
        const checkmarkSize = 4;
        const centerX = nX + nWidth / 2;
        const centerY = y + rowHeight / 2;

        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }
    }

    const remarksTextY = y + (rowHeight - remarksTextHeight) / 2;
    doc.text(remarks, remarksX + 5, remarksTextY, {
      width: remarksWidth - 10,
      align: 'center',
    });

    return y + rowHeight;
  };

  // Build all rows from the data
  const allRows: Array<{
    requirement: string;
    complied: boolean | undefined;
    remarks: string;
    isOthersMerged?: boolean; // Flag for "Others" section to always merge Y+N
    showNA?: boolean; // Flag to show "N/A" text in merged cell
    subRows?: Array<{
      requirement: string;
      complied: boolean | undefined;
      remarks: string;
    }>;
  }> = [];

  // 1) Compliance with EPEP Commitments
  if (exec.complianceWithEpepCommitments) {
    const epep = exec.complianceWithEpepCommitments;
    allRows.push({
      requirement: 'Compliance with EPEP Commitments',
      complied: undefined, // This is a group label, no checkmark
      remarks: epep.remarks || '',
      subRows: [
        {
          requirement: 'Safety',
          complied: epep.safety,
          remarks: '', // Remarks are handled by the parent
        },
        {
          requirement: 'Social',
          complied: epep.social,
          remarks: '', // Remarks are handled by the parent
        },
        {
          requirement: 'Rehabilitation',
          complied: epep.rehabilitation,
          remarks: '', // Remarks are handled by the parent
        },
      ],
    });
  }

  // 2) Compliance with SDMP Commitments
  if (exec.complianceWithSdmpCommitments) {
    const sdmp = exec.complianceWithSdmpCommitments;
    allRows.push({
      requirement: 'Compliance with SDMP Commitments',
      complied: sdmp.complied,
      remarks: sdmp.remarks || '',
    });
  }

  // 3) Complaints Management
  if (exec.complaintsManagement) {
    const cm = exec.complaintsManagement;
    allRows.push({
      requirement: 'Complaints Management',
      complied: cm.naForAll, // Parent compliance check
      remarks: cm.remarks || '',
      subRows: [
        {
          requirement: 'Complaint Receiving Setup',
          complied: cm.complaintReceivingSetup,
          remarks: '',
        },
        {
          requirement: 'Case Investigation',
          complied: cm.caseInvestigation,
          remarks: '',
        },
        {
          requirement: 'Implementation of Control',
          complied: cm.implementationOfControl,
          remarks: '',
        },
        {
          requirement: 'Communication with Complainant/Public',
          complied: cm.communicationWithComplainantOrPublic,
          remarks: '',
        },
        {
          requirement: 'Complaint Documentation',
          complied: cm.complaintDocumentation,
          remarks: '',
        },
      ],
    });
  }

  // 4) Accountability
  if (exec.accountability) {
    const acc = exec.accountability;
    allRows.push({
      requirement:
        'Accountability - qualified personnel are charged with the routine monitoring of the project activities in terms of education, training, knowledge and experience of the environmental team.',
      complied: acc.complied,
      remarks: acc.remarks || '',
    });
  }

  // 5) Others
  if (exec.others) {
    const oth = exec.others;
    allRows.push({
      requirement: 'Others, please specify',
      complied: oth.na,
      remarks: oth.specify || '',
      isOthersMerged: true, // Always merge Y+N for "Others"
      showNA: oth.na === true, // Show "N/A" text when na is true
    });
  }

  // Render the table
  let y = doc.y;
  y = drawHeader(y);

  for (const row of allRows) {
    if (row.subRows && row.subRows.length > 0) {
      const parentReqWidth = reqWidth * 0.3;
      const subReqWidth = reqWidth * 0.7;

      const subRows = row.subRows;
      const subRowMinHeight = 15; // Smaller min height for sub-rows
      const subRowHeights = subRows.map((subRow) => {
        const reqTextHeight = doc.heightOfString(subRow.requirement, {
          width: subReqWidth - 10,
        });
        // Remarks are not in subrows, so we don't need to calculate their height here
        return Math.max(subRowMinHeight, reqTextHeight) + 2; // Reduced padding
      });
      const totalSubRowHeight = subRowHeights.reduce((a, b) => a + b, 0);

      // --- Draw Merged Parent Cells ---
      doc.strokeColor('#000000').lineWidth(0.5);

      // Merged "Requirement" cell (parent label)
      doc
        .moveTo(left, y)
        .lineTo(left, y + totalSubRowHeight)
        .stroke(); // Left border
      doc
        .moveTo(left + parentReqWidth, y)
        .lineTo(left + parentReqWidth, y + totalSubRowHeight)
        .stroke(); // Right border

      const parentTextHeight = doc.heightOfString(row.requirement, {
        width: parentReqWidth - 10,
      });
      const parentTextY = y + (totalSubRowHeight - parentTextHeight) / 2;
      doc.font('Helvetica').text(row.requirement, left + 5, parentTextY, {
        width: parentReqWidth - 10,
        align: 'center',
      });
      doc.font('Helvetica');

      // Merged "Remarks" cell
      doc
        .moveTo(remarksX, y)
        .lineTo(remarksX, y + totalSubRowHeight)
        .stroke(); // Left border
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + totalSubRowHeight)
        .stroke(); // Right border

      const remarksTextHeight = doc.heightOfString(row.remarks, {
        width: remarksWidth - 10,
      });
      const remarksTextY = y + (totalSubRowHeight - remarksTextHeight) / 2;
      doc.text(row.remarks, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });

      // --- Draw the sub-rows ---
      let currentY = y;

      // Check if this is "Complaints Management" with naForAll = true
      const isComplaintsNA =
        row.requirement === 'Complaints Management' && row.complied === true;

      // If naForAll is true, draw merged Y+N columns with "N/A" text
      if (isComplaintsNA) {
        // Draw merged complied columns (Y+N) for the entire group
        const compliedMergedWidth = yWidth + nWidth;

        // Draw vertical borders for merged complied area
        doc
          .moveTo(yX, y)
          .lineTo(yX, y + totalSubRowHeight)
          .stroke(); // Left border of merged Y+N
        doc
          .moveTo(remarksX, y)
          .lineTo(remarksX, y + totalSubRowHeight)
          .stroke(); // Right border of merged Y+N

        // Draw "N/A" text centered in merged Y+N area
        const naText = 'N/A';
        const naTextHeight = doc.heightOfString(naText, {
          width: compliedMergedWidth - 10,
        });
        const naTextY = y + (totalSubRowHeight - naTextHeight) / 2;
        doc.font('Helvetica').text(naText, yX + 5, naTextY, {
          width: compliedMergedWidth - 10,
          align: 'center',
        });
      }

      for (let i = 0; i < subRows.length; i++) {
        const subRow = subRows[i];
        const subRowHeight = subRowHeights[i];

        // Draw sub-row content
        const subReqX = left + parentReqWidth;

        // Borders
        doc.moveTo(subReqX, currentY).lineTo(yX, currentY).stroke(); // Top border of sub-row's requirement cell
        doc
          .moveTo(subReqX, currentY)
          .lineTo(subReqX, currentY + subRowHeight)
          .stroke(); // Left border of sub-row's requirement cell (same as parent's right)

        // Only draw vertical borders in Y+N area if NOT naForAll
        if (!isComplaintsNA) {
          doc
            .moveTo(yX, currentY)
            .lineTo(yX, currentY + subRowHeight)
            .stroke(); // Right border of sub-row's requirement cell
          doc
            .moveTo(nX, currentY)
            .lineTo(nX, currentY + subRowHeight)
            .stroke(); // Right border of Y cell
          doc
            .moveTo(remarksX, currentY)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke(); // Right border of N cell
        } else {
          // For naForAll, only draw the right border of the remarks column
          doc
            .moveTo(remarksX, currentY)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke(); // Right border of merged Y+N cell
        }

        // Bottom border for the sub-row (only under requirement area, not Y+N area when naForAll)
        if (!isComplaintsNA) {
          doc
            .moveTo(subReqX, currentY + subRowHeight)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke();
        } else {
          // Only draw bottom border under requirement column when naForAll
          doc
            .moveTo(subReqX, currentY + subRowHeight)
            .lineTo(yX, currentY + subRowHeight)
            .stroke();
        }

        // Text for sub-row requirement
        const reqTextHeight = doc.heightOfString(subRow.requirement, {
          width: subReqWidth - 10,
        });
        const reqTextY = currentY + (subRowHeight - reqTextHeight) / 2;
        doc.text(subRow.requirement, subReqX + 5, reqTextY, {
          width: subReqWidth - 10,
          align: 'left',
        });

        // Checkmark for sub-row (only if not naForAll)
        if (!isComplaintsNA && subRow.complied === true) {
          const checkmarkSize = 4;
          const centerX = yX + yWidth / 2;
          const centerY = currentY + subRowHeight / 2;
          doc
            .save()
            .lineWidth(1.2)
            .moveTo(centerX - checkmarkSize, centerY)
            .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
            .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
            .stroke()
            .restore();
        }

        // Checkmark in N column for sub-row if false (only if not naForAll)
        if (!isComplaintsNA && subRow.complied === false) {
          const checkmarkSize = 4;
          const centerX = nX + nWidth / 2;
          const centerY = currentY + subRowHeight / 2;
          doc
            .save()
            .lineWidth(1.2)
            .moveTo(centerX - checkmarkSize, centerY)
            .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
            .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
            .stroke()
            .restore();
        }

        currentY += subRowHeight;
      }
      // Final bottom border for the entire group
      doc
        .moveTo(left, y + totalSubRowHeight)
        .lineTo(left + tableWidth, y + totalSubRowHeight)
        .stroke();

      y = currentY;
    } else {
      y = drawRow(y, row.requirement, row.complied, row.remarks, {
        isOthersMerged: row.isOthersMerged,
        showNA: row.showNA,
      });
    }
  }

  doc.y = y;
  doc.moveDown(1);
}
