import type { CMVRGeneralInfo } from './cmvr-pdf-generator.service';
import {
  formatDate,
  formatMaybeDateOrRange,
  getOrdinalSuffix,
  formatQuarterWithSuperscript,
} from './cmvr-pdf.helpers';

/**
 * Rendering helper functions for CMVR PDF generation
 * This file contains functions that directly manipulate the PDFDocument for rendering tables and text
 */

/**
 * Add footer to the PDF document
 */
export function addFooter(doc: PDFKit.PDFDocument): void {
  const text = 'Generated by MineComply';
  const y = doc.page.height - (doc.page.margins.bottom || 50) + 20;
  doc
    .font('Helvetica-Oblique')
    .fontSize(8)
    .fillColor('#666666')
    .text(text, doc.page.margins.left || 50, y, {
      width:
        doc.page.width -
        (doc.page.margins.left || 50) -
        (doc.page.margins.right || 50),
      align: 'center',
    })
    .fillColor('#000000');
}

/**
 * Draw a two-column key/value table WITHOUT a header row
 */
export function drawKeyValueTableNoHeader(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;
  const colWidths = [tableWidth * 0.5, tableWidth * 0.5];
  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the table (since there's no header)
  doc
    .moveTo(left, y)
    .lineTo(left + tableWidth, y)
    .stroke();

  for (const [key, value] of rows) {
    const textHeightLeft = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const textHeightRight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const rowHeight =
      Math.max(rowMinHeight, textHeightLeft, textHeightRight) + 3; // padding

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: left/right edges, internal divider, bottom line
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Column divider
    doc
      .moveTo(left + colWidths[0], y)
      .lineTo(left + colWidths[0], y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Cell text (centered vertically)
    const keyTextHeight = doc.heightOfString(key, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    const valueTextHeight = doc.heightOfString(value, {
      width: colWidths[1] - 10,
      align: 'center',
    });
    const keyTextY = y + (rowHeight - keyTextHeight) / 2;
    const valueTextY = y + (rowHeight - valueTextHeight) / 2;

    doc.font('Helvetica').text(key, left + 5, keyTextY, {
      width: colWidths[0] - 10,
      align: 'center',
    });
    doc
      .font('Helvetica-Bold')
      .text(value, left + colWidths[0] + 5, valueTextY, {
        width: colWidths[1] - 10,
        align: 'center',
      });

    y += rowHeight;
  }
  doc.moveDown(1);
}

/**
 * Draw a key/value table with label and colon columns (no header row)
 */
export function drawKeyValueTableWithColon(
  doc: PDFKit.PDFDocument,
  rows: Array<[string, string]>,
  suppressBottomSpacing?: boolean,
  customLabelColWidth?: number,
  customValueColWidth?: number,
  connectPrevious?: boolean,
): void {
  if (!rows || rows.length === 0) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Use custom widths if provided, otherwise use same dimensions as ECC/ISAG/MPP tables
  const labelColWidth = customLabelColWidth ?? 70;
  const colonColWidth = 15;
  const valueColWidth =
    customValueColWidth ?? tableWidth - labelColWidth - colonColWidth;

  const rowMinHeight = 14;
  let y = doc.y;

  doc.font('Helvetica').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Draw the top border of the entire table (skip if connecting to previous section)
  if (!connectPrevious) {
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();
  }

  for (const [key, value] of rows) {
    // Handle newlines in both key and value
    // Replace literal \n strings with actual newline characters
    // Also ensure existing newlines are preserved
    const processedKey = key.replace(/\\n/g, '\n');
    const processedValue = value.replace(/\\n/g, '\n');

    // Set font before measuring to ensure accurate height calculation
    doc.font('Helvetica-Bold').fontSize(11);
    const labelHeight = doc.heightOfString(processedKey, {
      width: labelColWidth - 10,
      align: 'left',
    });

    doc.font('Helvetica').fontSize(11);
    const valueHeight = doc.heightOfString(processedValue, {
      width: valueColWidth - 10,
      align: 'center',
    });

    const rowHeight = Math.max(rowMinHeight, labelHeight, valueHeight) + 8;

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      // draw top border for the new page segment
      doc
        .moveTo(left, y)
        .lineTo(left + tableWidth, y)
        .stroke();
    }

    // Row borders: outer edges and dividers
    // Left outer edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();
    // Divider between label and colon
    doc
      .moveTo(left + labelColWidth, y)
      .lineTo(left + labelColWidth, y + rowHeight)
      .stroke();
    // Divider between colon and value
    doc
      .moveTo(left + labelColWidth + colonColWidth, y)
      .lineTo(left + labelColWidth + colonColWidth, y + rowHeight)
      .stroke();
    // Bottom horizontal line
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke();

    // Draw label text (left-aligned, vertically centered)
    const labelTextY = y + (rowHeight - labelHeight) / 2;
    doc.font('Helvetica-Bold').text(processedKey, left + 5, labelTextY, {
      width: labelColWidth - 10,
      align: 'left',
    });

    // Draw colon (centered horizontally and vertically)
    const colonY = y + rowHeight / 2 - 5;
    doc.font('Helvetica-Bold').text(':', left + labelColWidth, colonY, {
      width: colonColWidth,
      align: 'center',
    });

    // Draw value text (center-aligned, vertically centered)
    const valueTextY = y + (rowHeight - valueHeight) / 2;
    doc
      .font('Helvetica')
      .text(
        processedValue,
        left + labelColWidth + colonColWidth + 5,
        valueTextY,
        {
          width: valueColWidth - 10,
          align: 'center',
        },
      );

    y += rowHeight;
  }

  // Update document cursor to the end of the table
  doc.y = y;

  if (!suppressBottomSpacing) {
    doc.moveDown(1);
  }
}

/**
 * Draw a table with optional merged label column
 */
export function drawTable(
  doc: PDFKit.PDFDocument,
  opts: {
    headers: string[];
    rows: string[][];
    labelColumn?: string;
    columnWidths?: number[]; // Optional: array of percentages (0-1) for each column
    connectPrevious?: boolean; // If true, visually connect this table to the previous one on the same page
    suppressBottomSpacing?: boolean; // If true, don't add extra spacing after the table
    suppressBottomBorder?: boolean; // If true, only draw bottom border under label area (another section follows)
  },
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // If labelColumn is provided, reserve space for label column + colon column on the left
  const labelColWidth = opts.labelColumn ? 70 : 0;
  const colonColWidth = opts.labelColumn ? 15 : 0;
  const dataTableWidth = tableWidth - labelColWidth - colonColWidth;

  // Calculate column widths - either custom or equal distribution
  let colWidths: number[];
  if (opts.columnWidths && opts.columnWidths.length === opts.headers.length) {
    // Use custom widths (percentages that should sum to 1.0)
    colWidths = opts.columnWidths.map((pct) => dataTableWidth * pct);
  } else {
    // Equal distribution
    const colWidth = dataTableWidth / opts.headers.length;
    colWidths = Array(opts.headers.length).fill(colWidth) as number[];
  }

  // Compute dynamic header height based on header text wrapping
  const rowMinHeight = 14;
  // Ensure header font is set before measuring
  doc.font('Helvetica-Bold').fontSize(11);
  const headerTextHeights = opts.headers.map((h, idx) =>
    doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    }),
  );
  const headerPadding = 10; // vertical padding within header
  const headerHeight = Math.max(25, ...headerTextHeights) + headerPadding;
  let y = doc.y;

  // Pre-calculate all row heights (use center align to match final rendering)
  const rowHeights: number[] = [];
  for (const row of opts.rows) {
    const heights = row.map((txt, idx) =>
      doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      }),
    );
    rowHeights.push(Math.max(rowMinHeight, ...heights) + 3);
  }

  // Determine if we should actually connect on this page (only if not at top of a new page)
  const topMargin = doc.page.margins.top || 50;
  const connectPrevHere = !!(opts.connectPrevious && doc.y > topMargin + 2);
  // Track whether to draw the section's top line (skip if connected to previous on same page)
  let shouldDrawSectionTop = !connectPrevHere;

  // Helper function to draw label and colon columns for a section
  const drawLabelSection = (
    startY: number,
    sectionHeight: number,
    drawTop: boolean,
    drawBottom: boolean,
  ) => {
    if (!opts.labelColumn) return;

    // Draw label column vertical edge (left outer edge)
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, startY)
      .lineTo(left, startY + sectionHeight)
      .stroke();

    // Draw top horizontal line spanning label + colon + data for this section (optional)
    if (drawTop) {
      doc
        .moveTo(left, startY)
        .lineTo(left + tableWidth, startY)
        .stroke();
    }

    // Bottom border handling (similar to fund section logic)
    if (drawBottom) {
      // Draw full width bottom border
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(left + tableWidth, startY + sectionHeight)
        .stroke();
    } else {
      // Only draw under label+colon area when another section follows
      const colonRight = left + labelColWidth + colonColWidth;
      doc
        .moveTo(left, startY + sectionHeight)
        .lineTo(colonRight, startY + sectionHeight)
        .stroke();
    }

    // Vertically center the label text
    const labelY = startY + sectionHeight / 2 - 5;
    doc
      .font('Helvetica-Bold')
      .fontSize(12)
      .text(opts.labelColumn.toUpperCase(), left + 5, labelY, {
        width: labelColWidth - 10,
        align: 'center',
      });

    // Draw colon column: only the divider between label and colon (no right edge to avoid double with dataLeft)
    const colonLeft = left + labelColWidth;
    doc
      .moveTo(colonLeft, startY)
      .lineTo(colonLeft, startY + sectionHeight)
      .stroke();

    // Vertically center the colon
    const colonY = startY + sectionHeight / 2 - 5;
    doc.font('Helvetica-Bold').fontSize(12).text(':', colonLeft, colonY, {
      width: colonColWidth,
      align: 'center',
    });
  };

  // Offset data columns to the right if label column exists
  const dataLeft = left + labelColWidth + colonColWidth;

  // Helper to get X position for a column (cumulative width up to that column)
  const getColX = (colIndex: number): number => {
    return (
      dataLeft + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0)
    );
  };

  // Track section start for merged label column
  let sectionStartY = y;
  let sectionRowsHeight = headerHeight; // Start with header height

  // Header for data columns - draw borders without double lines
  doc.font('Helvetica-Bold').fontSize(11).strokeColor('#000000').lineWidth(0.5);

  // Header outer edges
  doc
    .moveTo(dataLeft, y)
    .lineTo(dataLeft, y + headerHeight)
    .stroke(); // Left
  doc
    .moveTo(dataLeft + dataTableWidth, y)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Right
  // Top border is drawn by drawLabelSection to avoid double lines; skip drawing top here
  doc
    .moveTo(dataLeft, y + headerHeight)
    .lineTo(dataLeft + dataTableWidth, y + headerHeight)
    .stroke(); // Bottom

  // Header column dividers
  for (let i = 1; i < opts.headers.length; i++) {
    const colX = getColX(i);
    doc
      .moveTo(colX, y)
      .lineTo(colX, y + headerHeight)
      .stroke();
  }

  opts.headers.forEach((h, idx) => {
    const colX = getColX(idx);
    const textHeight = doc.heightOfString(h, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
    const textY = y + (headerHeight - textHeight) / 2; // vertical center
    doc.text(h, colX + 5, textY, {
      width: colWidths[idx] - 10,
      align: 'center',
    });
  });
  y += headerHeight;
  doc.font('Helvetica').fontSize(11);

  opts.rows.forEach((row, rowIndex) => {
    const rowHeight = rowHeights[rowIndex];

    // Page break if needed
    const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;
    if (y + rowHeight > bottomLimit) {
      // Draw label section for rows on current page before page break (not final, so respect suppressBottomBorder)
      drawLabelSection(
        sectionStartY,
        sectionRowsHeight,
        shouldDrawSectionTop,
        !opts.suppressBottomBorder, // drawBottom: false if another section follows
      );
      // After first segment, always draw top for subsequent segments
      shouldDrawSectionTop = true;

      doc.addPage();
      y = doc.page.margins.top || 50;

      // Reset section tracking for new page
      sectionStartY = y;
      sectionRowsHeight = headerHeight;

      // redraw header
      doc
        .font('Helvetica-Bold')
        .fontSize(11)
        .strokeColor('#000000')
        .lineWidth(0.5);

      // Header outer edges
      doc
        .moveTo(dataLeft, y)
        .lineTo(dataLeft, y + headerHeight)
        .stroke(); // Left
      doc
        .moveTo(dataLeft + dataTableWidth, y)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Right
      // Top border is handled by drawLabelSection later to avoid double lines; skip drawing top here
      doc
        .moveTo(dataLeft, y + headerHeight)
        .lineTo(dataLeft + dataTableWidth, y + headerHeight)
        .stroke(); // Bottom

      // Header column dividers
      for (let i = 1; i < opts.headers.length; i++) {
        const colX = getColX(i);
        doc
          .moveTo(colX, y)
          .lineTo(colX, y + headerHeight)
          .stroke();
      }
      opts.headers.forEach((h, idx) => {
        const colX = getColX(idx);
        const textHeight = doc.heightOfString(h, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
        const textY = y + (headerHeight - textHeight) / 2; // vertical center
        doc.text(h, colX + 5, textY, {
          width: colWidths[idx] - 10,
          align: 'center',
        });
      });
      y += headerHeight;
      doc.font('Helvetica').fontSize(11);
    }

    // Row borders (no double lines): draw left/right edges and the bottom line only
    // Left outer edge
    doc
      .moveTo(dataLeft, y)
      .lineTo(dataLeft, y + rowHeight)
      .stroke();
    // Right outer edge
    doc
      .moveTo(dataLeft + dataTableWidth, y)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();
    // Internal column dividers
    for (let i = 1; i < opts.headers.length; i++) {
      const colX = getColX(i);
      doc
        .moveTo(colX, y)
        .lineTo(colX, y + rowHeight)
        .stroke();
    }
    // Bottom horizontal line only under data area (preserve merged label/colon appearance)
    doc
      .moveTo(dataLeft, y + rowHeight)
      .lineTo(dataLeft + dataTableWidth, y + rowHeight)
      .stroke();

    // Row cells (centered horizontally and vertically)
    row.forEach((txt, idx) => {
      const colX = getColX(idx);
      const textHeight = doc.heightOfString(txt, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
      const textY = y + (rowHeight - textHeight) / 2; // vertical center
      doc.text(txt, colX + 5, textY, {
        width: colWidths[idx] - 10,
        align: 'center',
      });
    });

    y += rowHeight;
    sectionRowsHeight += rowHeight; // Accumulate height for label section
  });

  // Draw final label section for last page (this is the final segment)
  drawLabelSection(
    sectionStartY,
    sectionRowsHeight,
    shouldDrawSectionTop,
    !opts.suppressBottomBorder, // drawBottom: false if another section follows
  );

  // Update document cursor position to end of table
  doc.y = y;
  if (!opts.suppressBottomSpacing) {
    doc.moveDown(0.5);
  }
}

/**
 * Draw the summary text section with formatted title and company info
 */
export function drawSummaryText(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const width = right - left;
  const boxPct = 0.8;
  const boxPctLocation = 0.9;
  const y = width * boxPctLocation;
  const w = width * boxPct;
  const x = left + (width - w) / 2;
  const z = left + (width - y) / 2;

  doc.moveDown(0.8);

  // Title: "3rd QUARTER CY 2025 MMT COMPLIANCE MONITORING AND VALIDATION REPORT"
  doc.font('Helvetica-Bold').fontSize(11);

  const titleParts: string[] = [];
  if (gi.quarter) {
    // Format quarter with superscript ordinal (e.g., "3RD" becomes "3" with superscript "RD")
    const quarterFormatted = formatQuarterWithSuperscript(gi.quarter);
    titleParts.push(quarterFormatted);
  }
  if (gi.year) {
    titleParts.push(`CY ${gi.year}`);
  }
  titleParts.push('MMT COMPLIANCE MONITORING');

  // First line of title
  const titleLine1 = titleParts.join(' ');

  // If quarter has superscript, we need to manually draw it
  if (gi.quarter) {
    const yPos = doc.y;
    const quarterNum = gi.quarter.replace(/\D/g, ''); // Extract number
    const ordinal = getOrdinalSuffix(parseInt(quarterNum, 10)); // Get suffix

    // Build the text parts
    const afterQuarter = ' QUARTER';
    const restOfTitle = titleParts.slice(1).join(' ');

    // Measure to center the whole line (approximate with regular font for ordinal)
    const fullTextApprox = `${quarterNum}${ordinal}${afterQuarter} ${restOfTitle}`;
    const textWidth = doc.widthOfString(fullTextApprox);
    let xPos = left + (width - textWidth) / 2;

    // Draw quarter number
    doc.fontSize(11);
    doc.text(quarterNum, xPos, yPos, { continued: false });
    xPos += doc.widthOfString(quarterNum);

    // Draw ordinal as superscript (smaller font, raised) - no space before it
    doc.fontSize(7);
    const ordinalWidth = doc.widthOfString(ordinal);
    doc.text(ordinal, xPos, yPos - 1.5, { continued: false });
    xPos += ordinalWidth;

    // Draw rest of line
    doc.fontSize(11);
    doc.text(`${afterQuarter} ${restOfTitle}`, xPos, yPos, {
      continued: false,
    });
    doc.moveDown(0.5);
  } else {
    doc.text(titleLine1, left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  // Second line
  doc.text('AND VALIDATION REPORT', left, doc.y, {
    width: width,
    align: 'center',
  });
  doc.moveDown(2);

  // Company name centered
  if (gi.projectCurrentName) {
    doc.text(gi.projectCurrentName.toUpperCase(), left, doc.y, {
      width: width,
      align: 'center',
    });
  }

  doc.font('Helvetica');

  doc.text(
    `(This CMVR covers the ISAG Permit of ONRI and Fourteen (14) ISAG Permits under Supply Agreement with ONRI)`,
    x,
    doc.y,
    {
      width: w,
      align: 'center',
    },
  );

  doc.moveDown(1).font('Helvetica-Bold');

  // Display location field if it's a string, otherwise use mailing address
  if (typeof gi.location === 'string') {
    doc.text(gi.location.toUpperCase(), z, doc.y, {
      width: y,
      align: 'center',
    });
  }

  doc.moveDown(1);
}

/**
 * Add general info key-value pairs (compliance dates and summary)
 */
export function addGeneralInfoKeyValues(
  doc: PDFKit.PDFDocument,
  gi: CMVRGeneralInfo,
): void {
  // Render summary as formatted text (not a table) and compliance dates as a no-header table

  const complianceRows: Array<[string, string]> = [];

  if (gi.dateOfComplianceMonitoringAndValidation) {
    complianceRows.push([
      'Date of Compliance Monitoring and Validation',
      formatDate(gi.dateOfComplianceMonitoringAndValidation),
    ]);
  }
  if (gi.monitoringPeriodCovered) {
    complianceRows.push([
      'Monitoring Period Covered',
      formatMaybeDateOrRange(gi.monitoringPeriodCovered),
    ]);
  }
  if (gi.dateOfCmrSubmission) {
    complianceRows.push([
      'Date of CMR Submission',
      formatDate(gi.dateOfCmrSubmission),
    ]);
  }

  // Render summary section as formatted text (no "SUMMARY" title)
  drawSummaryText(doc, gi);

  if (complianceRows.length > 0) {
    // Render the three compliance-related rows as a separate table without a header
    drawKeyValueTableNoHeader(doc, complianceRows);
  }
}

/**
 * Draw "Executive Summary of Compliance" section with a multi-row header.
 * Header structure:
 *   Row 1: "Requirements" (merged 2 rows) | "Complied?" (spans Y+N) | "Remarks/ ECC or EPEP Condition #" (merged 2 rows)
 *   Row 2:                                 | "Y" | "N"                |
 *
 * For each requirement, mark Y or N based on boolean values.
 */
export function drawExecutiveSummaryOfCompliance(
  doc: PDFKit.PDFDocument,
  exec: NonNullable<CMVRGeneralInfo['executiveSummaryOfCompliance']>,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  const reqWidth = tableWidth * 0.57;
  const yWidth = tableWidth * 0.1;
  const nWidth = tableWidth * 0.1;
  const remarksWidth = tableWidth * 0.23;
  const compliedWidth = yWidth + nWidth; // "Complied?" spans Y + N

  const rowMinHeight = 14;
  const headerRow1Height = 20; // First header row
  const headerRow2Height = 18; // Second header row (Y/N)
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get column X positions
  const reqX = left;
  const yX = left + reqWidth;
  const nX = yX + yWidth;
  const remarksX = nX + nWidth;

  // Helper to draw the two-row header
  const drawHeader = (y: number) => {
    doc
      .strokeColor('#000000')
      .lineWidth(0.5)
      .font('Helvetica-Bold')
      .fontSize(11);

    // --- Header Row 1 ---
    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + headerRow1Height + headerRow2Height)
      .stroke();
    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + headerRow1Height + headerRow2Height)
      .stroke();

    // Vertical dividers for row 1
    doc
      .moveTo(yX, y)
      .lineTo(yX, y + headerRow1Height + headerRow2Height)
      .stroke(); // After Requirements
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + headerRow1Height + headerRow2Height)
      .stroke(); // After Complied?

    // Horizontal line after row 1
    doc
      .moveTo(yX, y + headerRow1Height)
      .lineTo(remarksX, y + headerRow1Height)
      .stroke();

    // Bottom border of header row 2
    doc
      .moveTo(left, y + headerRow1Height + headerRow2Height)
      .lineTo(left + tableWidth, y + headerRow1Height + headerRow2Height)
      .stroke();

    // --- Header Row 2 (Y/N sub-columns) ---
    doc
      .moveTo(nX, y + headerRow1Height)
      .lineTo(nX, y + headerRow1Height + headerRow2Height)
      .stroke();

    // Draw header texts
    // "Requirements" - vertically centered across both rows
    const reqText = 'Requirements';
    const reqTextHeight = doc.heightOfString(reqText, { width: reqWidth - 10 });
    const reqTextY =
      y + (headerRow1Height + headerRow2Height - reqTextHeight) / 2;
    doc.text(reqText, reqX + 5, reqTextY, {
      width: reqWidth - 10,
      align: 'center',
    });

    // "Complied?" - centered in row 1 only
    const compliedText = 'Complied?';
    const compliedTextHeight = doc.heightOfString(compliedText, {
      width: compliedWidth - 10,
    });
    const compliedTextY = y + (headerRow1Height - compliedTextHeight) / 2;
    doc.text(compliedText, yX + 5, compliedTextY, {
      width: compliedWidth - 10,
      align: 'center',
    });

    // "Remarks/ ECC or EPEP Condition #" - vertically centered across both rows
    const remarksText = 'Remarks/ ECC or EPEP Condition #';
    const remarksTextHeight = doc.heightOfString(remarksText, {
      width: remarksWidth - 10,
    });
    const remarksTextY =
      y + (headerRow1Height + headerRow2Height - remarksTextHeight) / 2;
    doc.text(remarksText, remarksX + 5, remarksTextY, {
      width: remarksWidth - 10,
      align: 'center',
    });

    // "Y" and "N" in row 2
    const yText = 'Y';
    const nText = 'N';
    const yTextY =
      y +
      headerRow1Height +
      (headerRow2Height - doc.heightOfString(yText, { width: yWidth - 10 })) /
        2;
    const nTextY =
      y +
      headerRow1Height +
      (headerRow2Height - doc.heightOfString(nText, { width: nWidth - 10 })) /
        2;
    doc.text(yText, yX + 5, yTextY, { width: yWidth - 10, align: 'center' });
    doc.text(nText, nX + 5, nTextY, { width: nWidth - 10, align: 'center' });

    return y + headerRow1Height + headerRow2Height;
  };

  // Helper to draw a data row
  const drawRow = (
    y: number,
    requirement: string,
    complied: boolean | undefined,
    remarks: string,
    options?: {
      isSubRow?: boolean;
      subRowParentHeight?: number;
      isFirstSubRow?: boolean;
      isLastSubRow?: boolean;
      isOthersMerged?: boolean; // Flag for "Others" section to always merge Y+N
      showNA?: boolean; // Flag to show "N/A" text in merged cell
    },
  ) => {
    const {
      isSubRow,
      subRowParentHeight,
      isFirstSubRow,
      isLastSubRow,
      isOthersMerged,
      showNA,
    } = options || {};

    doc.font('Helvetica').fontSize(11);
    const reqTextHeight = doc.heightOfString(requirement, {
      width: reqWidth - 10,
    });
    const remarksTextHeight = doc.heightOfString(remarks, {
      width: remarksWidth - 10,
    });
    const rowHeight =
      Math.max(rowMinHeight, reqTextHeight, remarksTextHeight) + 4;

    // Check page break
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica').fontSize(11);
    }

    // Draw row borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Right
    doc
      .moveTo(yX, y)
      .lineTo(yX, y + rowHeight)
      .stroke(); // After Requirements

    // Only draw Y/N divider if not "Others" (which always has merged Y+N)
    if (!isOthersMerged) {
      doc
        .moveTo(nX, y)
        .lineTo(nX, y + rowHeight)
        .stroke(); // Between Y and N
    }

    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + rowHeight)
      .stroke(); // After N (or after merged Y+N)
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Bottom

    // Draw texts
    const reqTextY = y + (rowHeight - reqTextHeight) / 2;
    doc.text(requirement, reqX + 5, reqTextY, {
      width: reqWidth - 10,
      align: 'left',
    });

    // If "Others" section (merged Y+N), conditionally show "N/A" or leave empty
    if (isOthersMerged) {
      const compliedMergedWidth = yWidth + nWidth;
      if (showNA) {
        const naText = 'N/A';
        const naTextHeight = doc.heightOfString(naText, {
          width: compliedMergedWidth - 10,
        });
        const naTextY = y + (rowHeight - naTextHeight) / 2;
        doc.font('Helvetica').text(naText, yX + 5, naTextY, {
          width: compliedMergedWidth - 10,
          align: 'center',
        });
      }
      // If showNA is false, the merged cell remains empty (no text drawn)
    } else {
      // Draw a checkmark manually if complied is true
      if (complied === true) {
        const checkmarkSize = 4;
        const centerX = yX + yWidth / 2;
        const centerY = y + rowHeight / 2;

        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      // Draw a checkmark in N column if complied is false
      if (complied === false) {
        const checkmarkSize = 4;
        const centerX = nX + nWidth / 2;
        const centerY = y + rowHeight / 2;

        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }
    }

    const remarksTextY = y + (rowHeight - remarksTextHeight) / 2;
    doc.text(remarks, remarksX + 5, remarksTextY, {
      width: remarksWidth - 10,
      align: 'center',
    });

    return y + rowHeight;
  };

  // Build all rows from the data
  const allRows: Array<{
    requirement: string;
    complied: boolean | undefined;
    remarks: string;
    isOthersMerged?: boolean; // Flag for "Others" section to always merge Y+N
    showNA?: boolean; // Flag to show "N/A" text in merged cell
    subRows?: Array<{
      requirement: string;
      complied: boolean | undefined;
      remarks: string;
    }>;
  }> = [];

  // 1) Compliance with EPEP Commitments
  if (exec.complianceWithEpepCommitments) {
    const epep = exec.complianceWithEpepCommitments;
    allRows.push({
      requirement: 'Compliance with EPEP Commitments',
      complied: undefined, // This is a group label, no checkmark
      remarks: epep.remarks || '',
      subRows: [
        {
          requirement: 'Safety',
          complied: epep.safety,
          remarks: '', // Remarks are handled by the parent
        },
        {
          requirement: 'Social',
          complied: epep.social,
          remarks: '', // Remarks are handled by the parent
        },
        {
          requirement: 'Rehabilitation',
          complied: epep.rehabilitation,
          remarks: '', // Remarks are handled by the parent
        },
      ],
    });
  }

  // 2) Compliance with SDMP Commitments
  if (exec.complianceWithSdmpCommitments) {
    const sdmp = exec.complianceWithSdmpCommitments;
    allRows.push({
      requirement: 'Compliance with SDMP Commitments',
      complied: sdmp.complied,
      remarks: sdmp.remarks || '',
    });
  }

  // 3) Complaints Management
  if (exec.complaintsManagement) {
    const cm = exec.complaintsManagement;
    allRows.push({
      requirement: 'Complaints Management',
      complied: cm.naForAll, // Parent compliance check
      remarks: cm.remarks || '',
      subRows: [
        {
          requirement: 'Complaint Receiving Setup',
          complied: cm.complaintReceivingSetup,
          remarks: '',
        },
        {
          requirement: 'Case Investigation',
          complied: cm.caseInvestigation,
          remarks: '',
        },
        {
          requirement: 'Implementation of Control',
          complied: cm.implementationOfControl,
          remarks: '',
        },
        {
          requirement: 'Communication with Complainant/Public',
          complied: cm.communicationWithComplainantOrPublic,
          remarks: '',
        },
        {
          requirement: 'Complaint Documentation',
          complied: cm.complaintDocumentation,
          remarks: '',
        },
      ],
    });
  }

  // 4) Accountability
  if (exec.accountability) {
    const acc = exec.accountability;
    allRows.push({
      requirement:
        'Accountability - qualified personnel are charged with the routine monitoring of the project activities in terms of education, training, knowledge and experience of the environmental team.',
      complied: acc.complied,
      remarks: acc.remarks || '',
    });
  }

  // 5) Others
  if (exec.others) {
    const oth = exec.others;
    allRows.push({
      requirement: 'Others, please specify',
      complied: oth.na,
      remarks: oth.specify || '',
      isOthersMerged: true, // Always merge Y+N for "Others"
      showNA: oth.na === true, // Show "N/A" text when na is true
    });
  }

  // Render the table
  let y = doc.y;
  y = drawHeader(y);

  for (const row of allRows) {
    if (row.subRows && row.subRows.length > 0) {
      const parentReqWidth = reqWidth * 0.3;
      const subReqWidth = reqWidth * 0.7;

      const subRows = row.subRows;
      const subRowMinHeight = 15; // Smaller min height for sub-rows
      const subRowHeights = subRows.map((subRow) => {
        const reqTextHeight = doc.heightOfString(subRow.requirement, {
          width: subReqWidth - 10,
        });
        // Remarks are not in subrows, so we don't need to calculate their height here
        return Math.max(subRowMinHeight, reqTextHeight) + 2; // Reduced padding
      });
      const totalSubRowHeight = subRowHeights.reduce((a, b) => a + b, 0);

      // --- Draw Merged Parent Cells ---
      doc.strokeColor('#000000').lineWidth(0.5);

      // Merged "Requirement" cell (parent label)
      doc
        .moveTo(left, y)
        .lineTo(left, y + totalSubRowHeight)
        .stroke(); // Left border
      doc
        .moveTo(left + parentReqWidth, y)
        .lineTo(left + parentReqWidth, y + totalSubRowHeight)
        .stroke(); // Right border

      const parentTextHeight = doc.heightOfString(row.requirement, {
        width: parentReqWidth - 10,
      });
      const parentTextY = y + (totalSubRowHeight - parentTextHeight) / 2;
      doc.font('Helvetica').text(row.requirement, left + 5, parentTextY, {
        width: parentReqWidth - 10,
        align: 'center',
      });
      doc.font('Helvetica');

      // Merged "Remarks" cell
      doc
        .moveTo(remarksX, y)
        .lineTo(remarksX, y + totalSubRowHeight)
        .stroke(); // Left border
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + totalSubRowHeight)
        .stroke(); // Right border

      const remarksTextHeight = doc.heightOfString(row.remarks, {
        width: remarksWidth - 10,
      });
      const remarksTextY = y + (totalSubRowHeight - remarksTextHeight) / 2;
      doc.text(row.remarks, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });

      // --- Draw the sub-rows ---
      let currentY = y;

      // Check if this is "Complaints Management" with naForAll = true
      const isComplaintsNA =
        row.requirement === 'Complaints Management' && row.complied === true;

      // If naForAll is true, draw merged Y+N columns with "N/A" text
      if (isComplaintsNA) {
        // Draw merged complied columns (Y+N) for the entire group
        const compliedMergedWidth = yWidth + nWidth;

        // Draw vertical borders for merged complied area
        doc
          .moveTo(yX, y)
          .lineTo(yX, y + totalSubRowHeight)
          .stroke(); // Left border of merged Y+N
        doc
          .moveTo(remarksX, y)
          .lineTo(remarksX, y + totalSubRowHeight)
          .stroke(); // Right border of merged Y+N

        // Draw "N/A" text centered in merged Y+N area
        const naText = 'N/A';
        const naTextHeight = doc.heightOfString(naText, {
          width: compliedMergedWidth - 10,
        });
        const naTextY = y + (totalSubRowHeight - naTextHeight) / 2;
        doc.font('Helvetica').text(naText, yX + 5, naTextY, {
          width: compliedMergedWidth - 10,
          align: 'center',
        });
      }

      for (let i = 0; i < subRows.length; i++) {
        const subRow = subRows[i];
        const subRowHeight = subRowHeights[i];

        // Draw sub-row content
        const subReqX = left + parentReqWidth;

        // Borders
        doc.moveTo(subReqX, currentY).lineTo(yX, currentY).stroke(); // Top border of sub-row's requirement cell
        doc
          .moveTo(subReqX, currentY)
          .lineTo(subReqX, currentY + subRowHeight)
          .stroke(); // Left border of sub-row's requirement cell (same as parent's right)

        // Only draw vertical borders in Y+N area if NOT naForAll
        if (!isComplaintsNA) {
          doc
            .moveTo(yX, currentY)
            .lineTo(yX, currentY + subRowHeight)
            .stroke(); // Right border of sub-row's requirement cell
          doc
            .moveTo(nX, currentY)
            .lineTo(nX, currentY + subRowHeight)
            .stroke(); // Right border of Y cell
          doc
            .moveTo(remarksX, currentY)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke(); // Right border of N cell
        } else {
          // For naForAll, only draw the right border of the remarks column
          doc
            .moveTo(remarksX, currentY)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke(); // Right border of merged Y+N cell
        }

        // Bottom border for the sub-row (only under requirement area, not Y+N area when naForAll)
        if (!isComplaintsNA) {
          doc
            .moveTo(subReqX, currentY + subRowHeight)
            .lineTo(remarksX, currentY + subRowHeight)
            .stroke();
        } else {
          // Only draw bottom border under requirement column when naForAll
          doc
            .moveTo(subReqX, currentY + subRowHeight)
            .lineTo(yX, currentY + subRowHeight)
            .stroke();
        }

        // Text for sub-row requirement
        const reqTextHeight = doc.heightOfString(subRow.requirement, {
          width: subReqWidth - 10,
        });
        const reqTextY = currentY + (subRowHeight - reqTextHeight) / 2;
        doc.text(subRow.requirement, subReqX + 5, reqTextY, {
          width: subReqWidth - 10,
          align: 'left',
        });

        // Checkmark for sub-row (only if not naForAll)
        if (!isComplaintsNA && subRow.complied === true) {
          const checkmarkSize = 4;
          const centerX = yX + yWidth / 2;
          const centerY = currentY + subRowHeight / 2;
          doc
            .save()
            .lineWidth(1.2)
            .moveTo(centerX - checkmarkSize, centerY)
            .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
            .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
            .stroke()
            .restore();
        }

        // Checkmark in N column for sub-row if false (only if not naForAll)
        if (!isComplaintsNA && subRow.complied === false) {
          const checkmarkSize = 4;
          const centerX = nX + nWidth / 2;
          const centerY = currentY + subRowHeight / 2;
          doc
            .save()
            .lineWidth(1.2)
            .moveTo(centerX - checkmarkSize, centerY)
            .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
            .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
            .stroke()
            .restore();
        }

        currentY += subRowHeight;
      }
      // Final bottom border for the entire group
      doc
        .moveTo(left, y + totalSubRowHeight)
        .lineTo(left + tableWidth, y + totalSubRowHeight)
        .stroke();

      y = currentY;
    } else {
      y = drawRow(y, row.requirement, row.complied, row.remarks, {
        isOthersMerged: row.isOthersMerged,
        showNA: row.showNA,
      });
    }
  }

  doc.y = y;
  doc.moveDown(1);
}

/**
 * Draw "Process Documentation of Activities Undertaken" section with a table.
 * Table structure:
 *   Header: Activities | Date Conducted | MMT Members Involved | Methodology/ Other Remarks
 *   First row after header: "Document Review of:" (merged across all columns)
 *   Then activity rows with members displayed vertically within cells
 */
export function drawProcessDocumentationOfActivitiesUndertaken(
  doc: PDFKit.PDFDocument,
  process: NonNullable<
    CMVRGeneralInfo['processDocumentationOfActivitiesUndertaken']
  >,
): void {
  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Column widths
  const activitiesWidth = tableWidth * 0.22;
  const dateWidth = tableWidth * 0.15;
  const membersWidth = tableWidth * 0.3;
  const remarksWidth = tableWidth * 0.27;

  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get column X positions
  const activitiesX = left;
  const dateX = left + activitiesWidth;
  const membersX = dateX + dateWidth;
  const remarksX = membersX + membersWidth;

  // Calculate dynamic header height based on text wrapping
  const calculateHeaderHeight = (): number => {
    doc.font('Helvetica-Bold').fontSize(11);
    const headers = [
      { text: 'Activities', width: activitiesWidth },
      { text: 'Date Conducted', width: dateWidth },
      { text: 'MMT Members Involved', width: membersWidth },
      { text: 'Methodology/ Other Remarks', width: remarksWidth },
    ];

    const headerTextHeights = headers.map((h) =>
      doc.heightOfString(h.text, {
        width: h.width - 10,
        align: 'center',
      }),
    );

    return Math.max(20, ...headerTextHeights) + 8; // Minimum 20px + 8px padding
  };

  const headerHeight = calculateHeaderHeight();

  // Helper to draw the header
  const drawHeader = (y: number) => {
    doc
      .strokeColor('#000000')
      .lineWidth(0.5)
      .font('Helvetica-Bold')
      .fontSize(11);

    // Top border
    doc
      .moveTo(left, y)
      .lineTo(left + tableWidth, y)
      .stroke();

    // Left edge
    doc
      .moveTo(left, y)
      .lineTo(left, y + headerHeight)
      .stroke();
    // Right edge
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + headerHeight)
      .stroke();

    // Vertical dividers
    doc
      .moveTo(dateX, y)
      .lineTo(dateX, y + headerHeight)
      .stroke();
    doc
      .moveTo(membersX, y)
      .lineTo(membersX, y + headerHeight)
      .stroke();
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + headerHeight)
      .stroke();

    // Bottom border
    doc
      .moveTo(left, y + headerHeight)
      .lineTo(left + tableWidth, y + headerHeight)
      .stroke();

    // Draw header texts
    const headers = [
      { text: 'Activities', x: activitiesX, width: activitiesWidth },
      { text: 'Date Conducted', x: dateX, width: dateWidth },
      { text: 'MMT Members Involved', x: membersX, width: membersWidth },
      {
        text: 'Methodology/ Other Remarks',
        x: remarksX,
        width: remarksWidth,
      },
    ];

    headers.forEach((header) => {
      const textHeight = doc.heightOfString(header.text, {
        width: header.width - 10,
      });
      const textY = y + (headerHeight - textHeight) / 2;
      doc.text(header.text, header.x + 5, textY, {
        width: header.width - 10,
        align: 'center',
      });
    });

    return y + headerHeight;
  };

  // Helper to draw the "Document Review of:" merged row
  const drawDocumentReviewRow = (y: number) => {
    doc.font('Helvetica-Bold').fontSize(11);
    const rowHeight = 18;

    // Check page break
    if (y + rowHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica-Bold').fontSize(11);
    }

    // Draw borders
    doc.strokeColor('#000000').lineWidth(0.5);
    doc
      .moveTo(left, y)
      .lineTo(left, y + rowHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Right
    doc
      .moveTo(left, y + rowHeight)
      .lineTo(left + tableWidth, y + rowHeight)
      .stroke(); // Bottom

    // Draw text
    const text = 'Document Review of:';
    const textHeight = doc.heightOfString(text, { width: tableWidth - 10 });
    const textY = y + (rowHeight - textHeight) / 2;
    doc.font('Helvetica');
    doc.text(text, left + 5, textY, {
      width: tableWidth - 10,
      align: 'left',
    });

    return y + rowHeight;
  };

  // Helper to draw an activity row with sub-rows for each member
  const drawActivityRowWithSubRows = (
    y: number,
    activityName: string,
    date: string,
    members: string[],
    remarks: string,
    options?: {
      remarksMode?: 'activity' | 'perMember' | 'none';
    },
  ) => {
    const remarksMode = options?.remarksMode ?? 'activity';
    doc.font('Helvetica').fontSize(11);

    const minSubRowHeight = 16; // Minimum height for each member sub-row

    // Calculate individual heights for each member
    const memberHeights = members.map((member) => {
      // Split member string by " - " to separate name and role
      const parts = member.split(' - ');
      const name = parts[0];
      const role = parts.length > 1 ? parts.slice(1).join(' - ') : '';

      // Calculate height for bold name
      doc.font('Helvetica-Bold').fontSize(11);
      const nameHeight = doc.heightOfString(name, {
        width: membersWidth - 10,
      });

      // Calculate height for regular role (if exists)
      let roleHeight = 0;
      if (role) {
        doc.font('Helvetica').fontSize(11);
        roleHeight = doc.heightOfString(role, {
          width: membersWidth - 10,
        });
      }

      const totalTextHeight = nameHeight + roleHeight;
      return Math.max(minSubRowHeight, totalTextHeight + 6); // Add padding
    });

    // Calculate total height needed from members
    const totalMemberRowsHeight = memberHeights.reduce((sum, h) => sum + h, 0);

    // Also consider the height of the activity name itself, as it might wrap
    const activityNameHeight = doc.heightOfString(activityName, {
      width: activitiesWidth - 10,
    });

    // The total height is the max of the height required by members and the height required by the activity name
    const totalSubRowsHeight = Math.max(
      totalMemberRowsHeight,
      activityNameHeight + 6, // Add padding to match member rows
    );

    // Check page break
    if (y + totalSubRowsHeight > bottomLimit) {
      doc.addPage();
      y = doc.page.margins.top || 50;
      y = drawHeader(y);
      doc.font('Helvetica').fontSize(11);
    }

    // Draw merged cells for Activity Name, Date, and Remarks
    doc.strokeColor('#000000').lineWidth(0.5);

    // Left border (Activity column)
    doc
      .moveTo(left, y)
      .lineTo(left, y + totalSubRowsHeight)
      .stroke();

    // Right border of Activity column
    doc
      .moveTo(dateX, y)
      .lineTo(dateX, y + totalSubRowsHeight)
      .stroke();

    // Right border of Date column
    doc
      .moveTo(membersX, y)
      .lineTo(membersX, y + totalSubRowsHeight)
      .stroke();

    // Right border of Members column
    doc
      .moveTo(remarksX, y)
      .lineTo(remarksX, y + totalSubRowsHeight)
      .stroke();

    // Right edge (end of Remarks column)
    doc
      .moveTo(left + tableWidth, y)
      .lineTo(left + tableWidth, y + totalSubRowsHeight)
      .stroke();

    // Bottom border - avoid drawing across merged remarks column when not rendering per member
    doc
      .moveTo(left, y + totalSubRowsHeight)
      .lineTo(remarksX, y + totalSubRowsHeight)
      .stroke();

    if (remarksMode !== 'none') {
      doc
        .moveTo(remarksX, y + totalSubRowsHeight)
        .lineTo(left + tableWidth, y + totalSubRowsHeight)
        .stroke();
    }

    // Draw Activity Name (vertically centered in merged cell)
    const activityTextHeight = doc.heightOfString(activityName, {
      width: activitiesWidth - 10,
    });
    const activityTextY = y + (totalSubRowsHeight - activityTextHeight) / 2;
    doc.text(activityName, activitiesX + 5, activityTextY, {
      width: activitiesWidth - 10,
      align: 'left',
    });

    // Always draw merged Date cell (one date per activity)
    const dateTextHeight = doc.heightOfString(date, {
      width: dateWidth - 10,
    });
    const dateTextY = y + (totalSubRowsHeight - dateTextHeight) / 2;
    doc.text(date, dateX + 5, dateTextY, {
      width: dateWidth - 10,
      align: 'center',
    });

    // Draw merged Remarks cell for entire activity
    if (remarksMode === 'activity') {
      const remarksTextHeight = doc.heightOfString(remarks, {
        width: remarksWidth - 10,
      });
      const remarksTextY = y + (totalSubRowsHeight - remarksTextHeight) / 2;
      doc.text(remarks, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });
    }

    // Draw sub-rows for each member
    let currentY = y;
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      const currentSubRowHeight = memberHeights[i];

      // Draw horizontal line between sub-rows (except for the first one)
      // Only draw between members column and remarks column (not through date column)
      if (i > 0) {
        if (remarksMode === 'activity' || remarksMode === 'none') {
          // When remarks are merged, only draw line in members column
          doc.moveTo(membersX, currentY).lineTo(remarksX, currentY).stroke();
        } else {
          // When remarks are not merged, draw line through members and remarks
          doc
            .moveTo(membersX, currentY)
            .lineTo(left + tableWidth, currentY)
            .stroke();
        }
      }

      // Split member string by " - " to separate name and role
      const parts = member.split(' - ');
      const name = parts[0];
      const role = parts.length > 1 ? parts.slice(1).join(' - ') : '';

      // Calculate heights for vertical centering
      doc.font('Helvetica-Bold').fontSize(11);
      const nameHeight = doc.heightOfString(name, {
        width: membersWidth - 10,
      });

      let roleHeight = 0;
      if (role) {
        doc.font('Helvetica').fontSize(11);
        roleHeight = doc.heightOfString(role, {
          width: membersWidth - 10,
        });
      }

      const totalTextHeight = nameHeight + roleHeight;
      const startY = currentY + (currentSubRowHeight - totalTextHeight) / 2;

      // Draw member name in bold
      doc.font('Helvetica-Bold').fontSize(11);
      doc.text(name, membersX + 5, startY, {
        width: membersWidth - 10,
        align: 'center',
        continued: false,
      });

      // Draw role in regular font on next line (if exists)
      if (role) {
        doc.font('Helvetica').fontSize(11);
        doc.text(role, membersX + 5, startY + nameHeight, {
          width: membersWidth - 10,
          align: 'center',
          continued: false,
        });
      }

      // Draw remarks per member when requested
      if (remarksMode === 'perMember') {
        // Remarks cell (use activity remarks)
        const remarksTextHeight = doc.heightOfString(remarks, {
          width: remarksWidth - 10,
        });
        const remarksTextY =
          currentY + (currentSubRowHeight - remarksTextHeight) / 2;
        doc.text(remarks, remarksX + 5, remarksTextY, {
          width: remarksWidth - 10,
          align: 'center',
        });
      }

      currentY += currentSubRowHeight;
    }

    return y + totalSubRowsHeight;
  };

  // Build activity rows
  const activities = process.activities;
  const globalDate = process.dateConducted || '';
  const globalRemarksText =
    (process.mergedMethodologyOrOtherRemarks ?? '').trim() || 'N/A';
  const useSameDate = process.sameDateForAllActivities;

  const activityRows: Array<{
    name: string;
    date: string;
    members: string[];
    remarks: string;
    remarksMode?: 'activity' | 'perMember' | 'none';
  }> = [];

  if (activities?.complianceWithEccConditionsCommitments) {
    const activity = activities.complianceWithEccConditionsCommitments;
    activityRows.push({
      name: 'Compliance with ECC Conditions/ Commitments',
      date: useSameDate ? globalDate : activity.dateConducted || globalDate,
      members: activity.mmtMembersInvolved || [],
      remarks: activity.remarks || '',
      remarksMode: 'none',
    });
  }

  if (activities?.complianceWithEpepAepepConditions) {
    const activity = activities.complianceWithEpepAepepConditions;
    activityRows.push({
      name: 'Compliance with EPEP/ AEPEP Conditions',
      date: useSameDate ? globalDate : activity.dateConducted || globalDate,
      members: activity.mmtMembersInvolved || [],
      remarks: activity.remarks || '',
      remarksMode: 'none',
    });
  }

  if (activities?.siteOcularValidation) {
    const activity = activities.siteOcularValidation;
    activityRows.push({
      name: 'Site Ocular/ Validation',
      date: useSameDate ? globalDate : activity.dateConducted || globalDate,
      members: activity.mmtMembersInvolved || [],
      remarks: activity.remarks || '',
      remarksMode: 'none',
    });
  }

  if (activities?.siteValidationConfirmatorySampling) {
    const activity = activities.siteValidationConfirmatorySampling;
    if (activity.applicable === false || activity.none === true) {
      activityRows.push({
        name: 'Site Validation/ Confirmatory Sampling',
        date: 'N/A',
        members: ['None'],
        remarks: activity.remarks || '',
        remarksMode: 'none',
      });
    } else {
      activityRows.push({
        name: 'Site Validation/ Confirmatory Sampling',
        date: useSameDate ? globalDate : activity.dateConducted || globalDate,
        members: activity.mmtMembersInvolved || [],
        remarks: activity.remarks || '',
        remarksMode: 'none',
      });
    }
  }

  // Render the table
  let y = doc.y;
  y = drawHeader(y);
  y = drawDocumentReviewRow(y);

  let remarksColumnStartY: number | null = null;

  for (const row of activityRows) {
    if (remarksColumnStartY === null) {
      remarksColumnStartY = y;
    }
    const remarksMode = row.remarksMode ?? 'none';
    y = drawActivityRowWithSubRows(
      y,
      row.name,
      row.date,
      row.members,
      row.remarks,
      { remarksMode },
    );
  }

  if (remarksColumnStartY !== null) {
    const remarksColumnHeight = y - remarksColumnStartY;
    if (remarksColumnHeight > 0) {
      doc.font('Helvetica').fontSize(11);
      const remarksTextHeight = doc.heightOfString(globalRemarksText, {
        width: remarksWidth - 10,
        align: 'center',
      });
      const remarksTextY =
        remarksColumnStartY +
        Math.max(0, (remarksColumnHeight - remarksTextHeight) / 2);

      // Draw enclosing borders for merged remarks column
      doc.moveTo(remarksX, remarksColumnStartY);
      doc.lineTo(remarksX, y).stroke();

      doc.moveTo(left + tableWidth, remarksColumnStartY);
      doc.lineTo(left + tableWidth, y).stroke();

      // Top border (connect to previous section)
      doc.moveTo(remarksX, remarksColumnStartY);
      doc.lineTo(left + tableWidth, remarksColumnStartY).stroke();

      // Bottom border of merged column
      doc.moveTo(remarksX, y);
      doc.lineTo(left + tableWidth, y).stroke();

      doc.text(globalRemarksText, remarksX + 5, remarksTextY, {
        width: remarksWidth - 10,
        align: 'center',
      });
    }
  }

  doc.y = y;
  doc.moveDown(1);
}

/**
 * Draw Compliance to Project Location and Coverage Limits table
 * 5 columns: Parameter | Specification | W/in Specs? (Y/N) | Remarks
 */
export function drawComplianceToProjectLocationTable(
  doc: PDFKit.PDFDocument,
  data: {
    parameters?: Array<{
      name?: string;
      specification?: string | Record<string, string | undefined>;
      withinSpecs?: boolean;
      remarks?: string | Record<string, string | undefined>;
    }>;
    otherComponents?: Array<{
      specification?: string;
      withinSpecs?: boolean;
      remarks?: string;
    }>;
  },
): void {
  if (!data || (!data.parameters && !data.otherComponents)) return;

  const left = doc.page.margins.left || 50;
  const right = doc.page.width - (doc.page.margins.right || 50);
  const tableWidth = right - left;

  // Column widths: Parameter 20%, Specification 35%, W/in Specs Y 8%, W/in Specs N 8%, Remarks 29%
  const colWidths = [
    tableWidth * 0.2, // Parameter
    tableWidth * 0.35, // Specification
    tableWidth * 0.08, // Y
    tableWidth * 0.08, // N
    tableWidth * 0.29, // Remarks
  ];

  const rowMinHeight = 14;
  const bottomLimit = doc.page.height - (doc.page.margins.bottom || 50) - 30;

  // Helper to get X position for a column
  const getColX = (colIndex: number): number => {
    return left + colWidths.slice(0, colIndex).reduce((sum, w) => sum + w, 0);
  };

  let y = doc.y;

  const headerRow1Height = 20;
  const headerRow2Height = 20;
  const totalHeaderHeight = headerRow1Height + headerRow2Height;

  // Helper function to draw the complex header
  const drawHeader = (yPos: number) => {
    doc
      .font('Helvetica-Bold')
      .fontSize(11)
      .strokeColor('#000000')
      .lineWidth(0.5);

    // --- Draw Borders ---
    // Outer borders
    doc
      .moveTo(left, yPos)
      .lineTo(left + tableWidth, yPos)
      .stroke(); // Top
    doc
      .moveTo(left, yPos)
      .lineTo(left, yPos + totalHeaderHeight)
      .stroke(); // Left
    doc
      .moveTo(left + tableWidth, yPos)
      .lineTo(left + tableWidth, yPos + totalHeaderHeight)
      .stroke(); // Right
    doc
      .moveTo(left, yPos + totalHeaderHeight)
      .lineTo(left + tableWidth, yPos + totalHeaderHeight)
      .stroke(); // Bottom

    // Main vertical dividers (spanning both rows)
    doc
      .moveTo(getColX(1), yPos)
      .lineTo(getColX(1), yPos + totalHeaderHeight)
      .stroke(); // After Parameter
    doc
      .moveTo(getColX(2), yPos)
      .lineTo(getColX(2), yPos + totalHeaderHeight)
      .stroke(); // After Specification
    doc
      .moveTo(getColX(4), yPos)
      .lineTo(getColX(4), yPos + totalHeaderHeight)
      .stroke(); // After W/in Specs block (before Remarks)

    // Horizontal divider inside W/in Specs?
    doc
      .moveTo(getColX(2), yPos + headerRow1Height)
      .lineTo(getColX(4), yPos + headerRow1Height)
      .stroke();

    // Vertical divider between Y and N (only in second row)
    doc
      .moveTo(getColX(3), yPos + headerRow1Height)
      .lineTo(getColX(3), yPos + totalHeaderHeight)
      .stroke();

    // --- Draw Text ---
    // Merged Row Headers (Parameter, Specification, Remarks)
    const mergedHeaders = [
      { text: 'Parameter', colIndex: 0 },
      { text: 'Specification', colIndex: 1 },
      {
        text: 'Remarks  Description of Actual Implementation ',
        colIndex: 4,
      },
    ];

    for (const header of mergedHeaders) {
      const textHeight = doc.heightOfString(header.text, {
        width: colWidths[header.colIndex] - 10,
        align: 'center',
      });
      const textY = yPos + (totalHeaderHeight - textHeight) / 2;
      doc.text(header.text, getColX(header.colIndex) + 5, textY, {
        width: colWidths[header.colIndex] - 10,
        align: 'center',
      });
    }

    // W/in Specs? (Row 1)
    const wInSpecsText = 'W/in Specs?';
    const wInSpecsWidth = colWidths[2] + colWidths[3];
    const wInSpecsTextHeight = doc.heightOfString(wInSpecsText, {
      width: wInSpecsWidth - 10,
      align: 'center',
    });
    const wInSpecsTextY = yPos + (headerRow1Height - wInSpecsTextHeight) / 2;
    doc.text(wInSpecsText, getColX(2) + 5, wInSpecsTextY, {
      width: wInSpecsWidth - 10,
      align: 'center',
    });

    // Y (Row 2)
    const yText = 'Y';
    const yTextHeight = doc.heightOfString(yText, {
      width: colWidths[2] - 10,
      align: 'center',
    });
    const yTextY =
      yPos + headerRow1Height + (headerRow2Height - yTextHeight) / 2;
    doc.text(yText, getColX(2) + 5, yTextY, {
      width: colWidths[2] - 10,
      align: 'center',
    });

    // N (Row 2)
    const nText = 'N';
    const nTextHeight = doc.heightOfString(nText, {
      width: colWidths[3] - 10,
      align: 'center',
    });
    const nTextY =
      yPos + headerRow1Height + (headerRow2Height - nTextHeight) / 2;
    doc.text(nText, getColX(3) + 5, nTextY, {
      width: colWidths[3] - 10,
      align: 'center',
    });

    return yPos + totalHeaderHeight;
  };

  y = drawHeader(y);

  // Data rows
  doc.font('Helvetica').fontSize(11);

  const rows: Array<{
    parameter: string;
    specification: string | Record<string, string | undefined>;
    withinSpecs: boolean;
    remarks: string | Record<string, string | undefined>;
    hasSubRows: boolean;
  }> = [];

  // Add parameters
  if (data.parameters) {
    for (const param of data.parameters) {
      const hasSubSpec =
        typeof param.specification === 'object' && param.specification !== null;
      const hasSubRemarks =
        typeof param.remarks === 'object' && param.remarks !== null;
      rows.push({
        parameter: param.name || '',
        specification: param.specification || '',
        withinSpecs: param.withinSpecs ?? false,
        remarks: param.remarks || '',
        hasSubRows: hasSubSpec || hasSubRemarks,
      });
    }
  }

  // Add otherComponents
  if (data.otherComponents) {
    for (const comp of data.otherComponents) {
      rows.push({
        parameter: 'Other Components',
        specification: comp.specification || '',
        withinSpecs: comp.withinSpecs ?? false,
        remarks: comp.remarks || '',
        hasSubRows: false,
      });
    }
  }

  for (const row of rows) {
    if (row.hasSubRows) {
      // Handle rows with sub-specifications
      const specEntries =
        typeof row.specification === 'object'
          ? Object.entries(row.specification)
          : [];

      // Calculate heights for each sub-row
      const subRowHeights: number[] = [];
      const maxSubRows = specEntries.length;

      // Helper function to format text with bullets
      const formatWithBullets = (text: string): string => {
        // Split by semicolons or existing bullet points (not commas to preserve sentences)
        const items = text
          .split(/;|/)
          .map((item) => item.trim())
          .filter((item) => item.length > 0);

        // If there's only one item or text is very short, return as is
        if (items.length <= 1 || text.length < 50) {
          return text;
        }

        // Join with bullets (using simple bullet that will render)
        return items.map((item) => ` ${item}`).join('\n');
      };

      for (let i = 0; i < maxSubRows; i++) {
        const specEntry = specEntries[i];

        let specHeight = 0;
        if (specEntry) {
          const [key, value] = specEntry;
          const specText = formatWithBullets(value || '');
          const keyLabel =
            key.charAt(0).toUpperCase() +
            key.slice(1) +
            (key.includes(':') ? '' : ':');

          // Calculate label height
          const labelHeight = doc.heightOfString(keyLabel, {
            width: colWidths[1] - 10,
            align: 'center',
          });

          // Calculate text height (use left alignment for bullets)
          const textHeight = doc.heightOfString(specText, {
            width: colWidths[1] - 10,
            align: 'left',
          });

          // Total height includes label + line spacing + text
          specHeight = labelHeight + 4 + textHeight;
        }

        subRowHeights.push(Math.max(rowMinHeight, specHeight) + 10);
      }

      const totalRowHeight = subRowHeights.reduce((sum, h) => sum + h, 0);

      // Page break if needed
      if (y + totalRowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        y = drawHeader(y);
        doc.font('Helvetica').fontSize(11);
      }

      // Draw merged Parameter column
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + totalRowHeight)
        .stroke();
      doc
        .moveTo(getColX(1), y)
        .lineTo(getColX(1), y + totalRowHeight)
        .stroke();

      const paramTextHeight = doc.heightOfString(row.parameter, {
        width: colWidths[0] - 10,
        align: 'center',
      });
      const paramTextY = y + (totalRowHeight - paramTextHeight) / 2;
      doc.text(row.parameter, getColX(0) + 5, paramTextY, {
        width: colWidths[0] - 10,
        align: 'center',
      });

      // Draw merged W/in Specs columns
      doc
        .moveTo(getColX(2), y)
        .lineTo(getColX(2), y + totalRowHeight)
        .stroke();
      doc
        .moveTo(getColX(3), y)
        .lineTo(getColX(3), y + totalRowHeight)
        .stroke();
      doc
        .moveTo(getColX(4), y)
        .lineTo(getColX(4), y + totalRowHeight)
        .stroke();

      // Draw checkmark in merged W/in Specs area
      if (row.withinSpecs) {
        const checkmarkSize = 4;
        const centerX = getColX(2) + colWidths[2] / 2;
        const centerY = y + totalRowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      } else {
        const checkmarkSize = 4;
        const centerX = getColX(3) + colWidths[3] / 2;
        const centerY = y + totalRowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      // Render remarks as merged cell (always, whether string or object)
      let remarksText = '';
      if (typeof row.remarks === 'string') {
        remarksText = formatWithBullets(row.remarks);
      } else if (typeof row.remarks === 'object' && row.remarks !== null) {
        // If remarks is an object, concatenate all values
        remarksText = Object.values(row.remarks)
          .filter((val) => val)
          .map((val) => formatWithBullets(val as string))
          .join('\n\n');
      }

      if (remarksText.length > 0) {
        const remarksTextHeight = doc.heightOfString(remarksText, {
          width: colWidths[4] - 10,
          align: 'left',
        });
        const remarksTextY = y + (totalRowHeight - remarksTextHeight) / 2;
        doc.font('Helvetica').fontSize(11);
        doc.text(remarksText, getColX(4) + 5, remarksTextY, {
          width: colWidths[4] - 10,
          align: 'left',
        });
      }

      // Draw sub-rows
      let currentY = y;
      for (let i = 0; i < maxSubRows; i++) {
        const subRowHeight = subRowHeights[i];
        const specEntry = specEntries[i];

        // Draw horizontal divider only in Specification column (except for first row)
        if (i > 0) {
          doc
            .moveTo(getColX(1), currentY)
            .lineTo(getColX(2), currentY)
            .stroke();
        }

        // Specification sub-row
        if (specEntry) {
          const [key, value] = specEntry;
          const specText = formatWithBullets(value || '');

          // Format the key as a label (capitalize first letter, add colon if not present)
          const keyLabel =
            key.charAt(0).toUpperCase() +
            key.slice(1) +
            (key.includes(':') ? '' : ':');

          // Calculate label height
          const labelHeight = doc.heightOfString(keyLabel, {
            width: colWidths[1] - 10,
            align: 'center',
          });

          // Calculate text height
          const textHeight = doc.heightOfString(specText, {
            width: colWidths[1] - 10,
            align: 'left',
          });

          // Calculate total content height and position
          const totalContentHeight = labelHeight + 4 + textHeight;
          const startY = currentY + (subRowHeight - totalContentHeight) / 2;

          // Draw label in bold, centered
          doc.font('Helvetica-Bold').fontSize(10);
          doc.text(keyLabel, getColX(1) + 5, startY, {
            width: colWidths[1] - 10,
            align: 'center',
            continued: false,
          });

          // Draw horizontal line below label (full width)
          const lineY = startY + labelHeight + 2;
          doc
            .strokeColor('#000000')
            .lineWidth(0.5)
            .moveTo(getColX(1), lineY)
            .lineTo(getColX(1) + colWidths[1], lineY)
            .stroke();

          // Draw value in regular font, left-aligned
          doc.font('Helvetica').fontSize(11);
          doc.text(specText, getColX(1) + 5, lineY + 2, {
            width: colWidths[1] - 10,
            align: 'left',
          });
        }

        currentY += subRowHeight;
      }

      // Draw bottom border and right edge
      doc
        .moveTo(left, y + totalRowHeight)
        .lineTo(left + tableWidth, y + totalRowHeight)
        .stroke();
      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + totalRowHeight)
        .stroke();

      y += totalRowHeight;
    } else {
      // Simple row without sub-specifications
      const specText =
        typeof row.specification === 'string' ? row.specification : '';
      const remarksText = typeof row.remarks === 'string' ? row.remarks : '';

      const paramHeight = doc.heightOfString(row.parameter, {
        width: colWidths[0] - 10,
        align: 'center',
      });
      const specHeight = doc.heightOfString(specText, {
        width: colWidths[1] - 10,
        align: 'center',
      });
      const remarksHeight = doc.heightOfString(remarksText, {
        width: colWidths[4] - 10,
        align: 'center',
      });
      const rowHeight =
        Math.max(rowMinHeight, paramHeight, specHeight, remarksHeight) + 6;

      // Page break if needed
      if (y + rowHeight > bottomLimit) {
        doc.addPage();
        y = doc.page.margins.top || 50;
        y = drawHeader(y);
        doc.font('Helvetica').fontSize(11);
      }

      // Draw row borders
      doc.strokeColor('#000000').lineWidth(0.5);
      doc
        .moveTo(left, y)
        .lineTo(left, y + rowHeight)
        .stroke();

      for (let i = 1; i <= 4; i++) {
        doc
          .moveTo(getColX(i), y)
          .lineTo(getColX(i), y + rowHeight)
          .stroke();
      }

      doc
        .moveTo(left + tableWidth, y)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();
      doc
        .moveTo(left, y + rowHeight)
        .lineTo(left + tableWidth, y + rowHeight)
        .stroke();

      // Draw cell content
      const paramTextHeight = doc.heightOfString(row.parameter, {
        width: colWidths[0] - 10,
        align: 'center',
      });
      const paramTextY = y + (rowHeight - paramTextHeight) / 2;
      doc.text(row.parameter, getColX(0) + 5, paramTextY, {
        width: colWidths[0] - 10,
        align: 'center',
      });

      const specTextHeight = doc.heightOfString(specText, {
        width: colWidths[1] - 10,
        align: 'center',
      });
      const specTextY = y + (rowHeight - specTextHeight) / 2;
      doc.text(specText, getColX(1) + 5, specTextY, {
        width: colWidths[1] - 10,
        align: 'center',
      });

      // Draw checkmark
      if (row.withinSpecs) {
        const checkmarkSize = 4;
        const centerX = getColX(2) + colWidths[2] / 2;
        const centerY = y + rowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      } else {
        const checkmarkSize = 4;
        const centerX = getColX(3) + colWidths[3] / 2;
        const centerY = y + rowHeight / 2;
        doc
          .save()
          .lineWidth(1.2)
          .moveTo(centerX - checkmarkSize, centerY)
          .lineTo(centerX - checkmarkSize / 2, centerY + checkmarkSize)
          .lineTo(centerX + checkmarkSize, centerY - checkmarkSize)
          .stroke()
          .restore();
      }

      const remarksTextHeight = doc.heightOfString(remarksText, {
        width: colWidths[4] - 10,
        align: 'center',
      });
      const remarksTextY = y + (rowHeight - remarksTextHeight) / 2;
      doc.text(remarksText, getColX(4) + 5, remarksTextY, {
        width: colWidths[4] - 10,
        align: 'center',
      });

      y += rowHeight;
    }
  }

  doc.y = y;
  doc.moveDown(0.5);
}
